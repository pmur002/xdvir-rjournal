---
title: "Rendering LaTeX in R"
date: "2024-12-31"
abstract: >
  An abstract of less than 150 words.
draft: true
author:  
  - name: Paul Murrell
    affiliation: The University of Auckland
    address:
    - Department of Statistics
    - Auckland, New Zealand
    email: paul@stat.auckland.ac.nz
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
type: package
output: 
  rjtools::rjournal_web_article:
    self_contained: yes
    toc: no
bibliography: murrell-xdvir.bib

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
options(xdvir.engine="xetex")
```

# Introduction

Text labels, titles, and annotations are essential components of 
any data visualisation.  Viewers focus a lot of their attention
on text [@massvis], 
text is the most effective way to communicate some types of 
information [@hearst],
and the message obtained from a data visualisation can be
heavily influenced by text [@kong].

R provides relatively flexible tools for adding text labels to plots.
For example, in the `graphics` package, we can specify an
overall title and axis titles via the `main`,
`xlab`, and `ylab` arguments to the `plot()` function
and we can add text at arbitrary locations on the plot with the `text()` 
and `mtext()` functions.

Unfortunately, these core tools for drawing text are quite limited
in terms of the formatting of the text.
For example, there is no facility for emphasising an individual word using
a **bold** or *italic* face within a text label.

The \CRANpkg{gridtext} [@pkg-gridtext] and \CRANpkg{ggtext} [@pkg-ggtext]
packages greatly improved the situation by allowing text labels
to include a small subset of
markdown and HTML (plus CSS).  This allowed changes in font face
and colour within text labels.

More recently, the \CRANpkg{marquee} package [@pkg-marquee]
improved things a great deal further by providing full support for
markdown within text labels.  This made it possible to layout more
complex arrangements of text and graphical content within "text" labels.

However, despite these advances, there are still some text formatting tasks that
remain out of reach.  For example, Figure \@ref(fig:typesetting) 
shows a plot with a text annotation in the top-right corner containing
a combination of features that cannot be produced using the 
available text-drawing tools.

```{r echo=FALSE}
## Parameter for plotting
## Set x variable for the fitness function 
x <- seq(-1, 7.5, by = .01)

## Math parameters for Fitness function 
s <- .5
m <- 1.5
t <- 1.7
u <- 3.4
div1 <- 2.4
div2 <- 3.5

## Set population parameters
## NB individuals, try with 10, and 1000 
n <- 1000 
## Get fake phenotypes
## Phenotypes for the population
pheno <- rnorm(n = n, mean = 3.2, sd = 0.5) 
## Make y height just for vizualisation purpose 
fit <- rnorm(length(pheno), mean = .12, sd =.01)


## Load functions ----------------------------------------------------------
## Mathematical fitness function (2 peaks )
## This is a speculative fitness function, you could design your own.
fit.function  <- function(x, s, m, t, u, div1 = 2, div2 = 2.5) {
    exp(-s^(-2)*(x-m)^(2))/div1+exp(-t^(-2)*(x-u)^(2))/div2
}

y <- fit.function(x = x,s = s, m = m,t = t,u = u, div1 = div1, div2 = div2)

main.plot <- function(mar = c(3, 3, .25, .25), col = 2) {
    ## Set parameter of plotting area 
    par(mar = mar)
    ## Plot fitness function 
    plot(y ~ x, 
         xlim = c(-0.5, 7),
         ylim = c(0, .7),
         axes=FALSE,
         type = "l", lwd = 5, col = col, 
         ylab = "Fitness", xlab = "Phenotypes")
    axis(1)
    axis(2, at=seq(0, .6, .2))
    box()
}

dens.xy <- density(x = pheno, n = 512, adjust = 2) # Adjust to make it smoother 

## Make a fake population 
add.fake.pop <-  function(x = dens.xy, y = fit,  alp = 1) {
    ## Line at the mean 
    ## abline(v = mean(x), lty = 3)
    ## Calculate the density of the population 
    ## Add density 
    lines(x = dens.xy$x, y = dens.xy$y/3, lty = 2)
}

drawPlot <- function() {
    par(family="TeX Gyre Adventor", mgp=c(2, .7, 0))
    main.plot()
    add.fake.pop(alp = .1)
}
```

```{r, echo=FALSE}
annotationTeX <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the \textcolor{Rred}{\bf fitness function}.
\end{minipage})"
```

```{r, typesetting, echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=4.5, dpi=300, fig.keep="last", fig.cap="A plot with a text annotation that contains several typesetting challenges:  in-line mathematical equations; changes in colour; and automated line-breaks with full justification and hyphenation. Thanks to Marc-Olivier Beausoleil for permission to reproduce this data visualisation."}

library(xdvir)
adventor <- fontspecPackage(font="TeX Gyre Adventor", name="adventor")

library(gggrid)

ggIntro <- ggplot(data.frame(x, y)) +
    geom_line(aes(x, y), linewidth=2, colour=2) +
    geom_line(aes(x, y), data=data.frame(x=dens.xy$x, y=dens.xy$y/3),
              linetype="dashed") +
    xlab("Phenotypes") +
    ylab("Fitness") +
    theme_bw() +
    theme(text=element_text(family="TeX Gyre Adventor", size=12),
          panel.grid=element_blank())

label <- function(data, coords) {
    latexGrob(annotationTeX, packages=list(adventor, "xcolor"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL,
              texFile="typesetting.tex")
}

ggIntro + 
    grid_panel(label, aes(x, y))
```

The annotation in Figure \@ref(fig:typesetting)
may not appear to be particularly special nor particularly complicated 
at first glance, but it harbours several important details:

* The text is a mixture of plain text and mathematical expressions (like
  $\bar{z}_i$). Furthermore, the mathematical expressions use a different font
  (Latin Modern) than the plain text (TeX Gyre Adventor).

  The R graphics system can draw mathematical expressions [@plotmath]
  and that includes a mixture of plain text and mathematical expressions,
  but it can only use the same font for the entire mixture.
  There is also the problem
  that the typesetting of mathematical expressions in R graphics is not
  particularly pretty.

* The text is not all the same colour; the final two words (but not the full
  stop) are red.  Furthermore, the final two words are **bold**;
  they have a different
  font face compared to the rest of the text.

  The R graphics system can only draw a character value with a single colour
  and a single font face.
  The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages make it possible to change colour within
  a character value, but they do not allow a mixture of plain text and
  mathematical expressions.

* The text is broken over multiple lines. Furthermore, the text is fully
  justified (not ragged-left or ragged-right justified) and one word
  has been split across lines and hyphenated. Although it is not
  obvious from the plot itself, the line breaks were also automatically
  generated to fit the text into a fixed width (3 inches).

  The R graphics system can draw a character value across multiple lines, but
  only if explicit newlines are embedded in the character value (i.e., the line
  breaks are manual). The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages can calculate simple
  automated line breaks, but they will not break a word across lines (or
  hyphenate) and they cannot fully justify the resulting text. The
  \CRANpkg{marquee} package can automate line breaks and fully justify
  text, but it cannot hyphenate nor can it produce mathematical equations.

The features outlined above are all examples of *typesetting*; determining an
arrangement of individual characters and symbols (glyphs) that could be as
simple as placing one character after another (from left to right), but could
also be as complex as arranging mathematical symbols, splitting text into
multiple columns, or writing text vertically from top to bottom.

From R 4.3.0, it has been
possible to draw text from a set of typeset glyphs using the
functions `grDevices::glyphInfo()` and `grid::grid.glyph()`
[@murrell-pedersen-urbanek-glyphs-2023]. However, that
facility presupposes that we are able to generate a set of typeset glyphs.

The \CRANpkg{marquee} package provides an example of a package
that can generate typeset glyphs.  It is capable of converting
markdown input into a set of glyphs and their positions, which are
then rendered in R.

This article describes the `xdvir` package, which is another example
of a package that can generate typeset glyphs.
In this case, the input is LaTeX, a TeX engine is used to
generate a set of glyphs and their positions, and then the
result is rendered in R.
The benefit of the `xdvir` package is that it provides access to the
typesetting capabilities of LaTeX, which includes hyphenation,
fully justified text, mixtures of plain text and mathematical equations---all
of the features demonstrated in Figure \@ref(fig:typesetting) and much more.

The next section describes the basic usage of the `xdvir` package.
This is followed by a section that breaks down the 
design of the `xdvir` package to show the steps that are
required to render LaTeX output in R.
Subsequent sections explore several of the complexities 
that can arise with rendering LaTeX text in R graphics and 
some of the solutions that 
the `xdvir` package provides.

# LaTeX text labels in R

The simplest way to draw LaTeX text with the `xdvir` package 
is to call the `grid.latex()` function.  The first argument to
this function is a character value, which is interpreted as
a fragment of LaTeX code.
For example, the following code draws a text label that contains
a fragment of the larger annotation from 
Figure \@ref(fig:typesetting).  We use just a fragment here in order
to keep the code readable.

Because LaTeX code tends to contain 
a large number of backslashes, the code below uses the `r"(...)"`
syntax for raw character constants, so that we do not have to
escape each backslash with a double backslash.
The resulting image is shown below the code.
Although it is not immediately obvious from that image, 
the text, or rather the glyphs, in the image are rendered by R.

```{r, fragment}
simpleTeX <- r"(We move the original mean to $\bar z_i$)"
```

```{r grid.latex, fig.width=3, fig.height=.5}
grid.rect()
grid.latex(simpleTeX)
```

It is possible to produce something similar to this result using 
the "plotmath" feature in R, as shown in the following code (and the image
below the code).  However, this demonstrates that
one advantage of using `xdvir`, even for a simple
piece of text like this, is the superior quality of the LaTeX 
fonts and typesetting for mathematical expressions.

```{r, plotmath}
plotmath <- expression("We move the original mean to "*bar(italic(z))[i])
```

```{r, fig.width=3, fig.height=.5}
grid.rect()
grid.text(plotmath)
```

Another immediate benefit of `xdvir` is that we can automatically fit
the text within a specified width.
For example, the following code draws the LaTeX fragment `tex`
again, but this time forces it to fit within a column that is half
the width of the image.

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.latex(simpleTeX, width=.5)
```

As the function name `grid.latex()` suggests, that function
produces low-level 
drawing in the `grid` package graphics system.
The text is just drawn relative to the current `grid` viewport,
wherever that may be on the page.
While this is extremely flexible, it is more likely that 
we want to combine and coordinate the text with a high-level plot
of some sort, like the annotation in Figure \@ref(fig:typesetting).
There are various ways that low-level `grid` drawing can be combined
with a high-level plot, but we will leave those demonstrations to
later sections.

Instead, for now, we will demonstrate a more common scenario:
drawing LaTeX text labels on a \CRANpkg{ggplot2} plot [@pkg-ggplot2].
For this purpose, the `xdvir` package provides the
`element_latex()` function.  This allows us to specify a LaTeX fragment
as a plot label and indicate the special nature of the label
via the `ggplot2::theme()` function.

For example, the following code uses the same LaTeX fragment 
from the example above as the title of a \CRANpkg{ggplot2} plot.
The resulting plot is shown in Figure \@ref(fig:elementlatex).
One detail about this result is that the text in this title is larger 
than the text drawn by the call to `grid.latex()` above.
A closer inspection reveals that the font is also different.
This reflects the fact that `grid.latex()` and `element_latex()`
respect the graphical parameter settings---font families and font sizes---that
are in effect when the LaTeX fragment is drawn.  In 
\@ref(fig:elementlatex) that means respecting the theme settings
of the \CRANpkg{ggplot2} plot.

The `ggIntro` object in the code below
contains a description of the main \CRANpkg{ggplot2} 
plot from Figure 
\@ref(fig:typesetting).
The code for generating 
`ggIntro` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

```{r, elementlatex, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=4.5, dpi=300, fig.cap="A `ggplot2` plot with a title that was specified using a LaTeX fragment."}
ggIntro +
    labs(title=simpleTeX) +
    theme(plot.title=element_latex())
```

The `xdvir` package also provides a `geom_latex()` function for
drawing text labels, similar to the standard `ggplot2::geom_text()` function.
The `label` aesthetic for `geom_latex()` is treated as a fragment of LaTeX
code.
For example, the following code draws a plot with a set of red points
and a set of red labels, one for each point.
The points are drawn using the standard `ggplot::geom_point()` function,
but the labels are drawn using `geom_latex()` from the `xdvir` package.
The result is shown in Figure \@ref(fig:geomlatex).

```{r tikzmu}
muDot <- r"(%
\begin{tikzpicture}
\node[draw,circle,thick,inner sep=0.5mm]{\vphantom{M}$\mu$};
\end{tikzpicture})"
```
```{r echo=FALSE}
samples <- data.frame(x=rnorm(50), sample=rep(1:5, each=10))
means <- aggregate(samples$x, list(sample=samples$sample), mean)
means$label <- paste0("$\\bar x_", means$sample, "$")
```

```{r, echo=FALSE, message=FALSE}
ggGeom <- ggplot(samples) +
    geom_vline(xintercept=0, linetype="solid", colour=1, linewidth=.5) +
    geom_point(aes(x, sample), colour="grey", size=4, alpha=.5) +
    xlab(NULL) +
    scale_x_continuous(breaks=0, labels=muDot) +
    scale_y_continuous(breaks=1:5, expand=expansion(.25)) +
    theme_minimal() +
    theme(axis.text.x=element_latex(size=16, packages="tikz", 
                                    margin=margin(-3, 0, 0, 0)),
          axis.ticks.x=element_blank(),
          axis.title.y=element_text(colour="grey"),
          axis.text.y=element_text(colour="grey"),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.x=element_blank(),
          panel.grid.minor.y=element_blank())
```

The `ggGeom` object in the code below describes the 
main plot, consisting of grey dots, horizontal and vertical lines,
and y-axis labels.
The code for generating 
`ggGeom` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

```{r, geomlatex, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=3.5, dpi=300, fig.cap="A `ggplot2` plot with text labels drawn using `geom_latex()`."}
ggGeom +
    geom_point(aes(x, sample), data=means, colour=2, size=4) +
    geom_latex(aes(x, sample, label=label), data=means, 
               size=6, vjust=-.4, colour=2)    
```

The red labels for the red points in Figure \@ref(fig:geomlatex)
are small LaTeX fragments that each describe 
a simple LaTeX mathematical expression, as shown below.

```{r}
means$label
```

# Under the Hood

The previous section showed that simple usage of the `xdvir` package
only requires specifying a LaTeX fragment as the text to draw.
For example, the examples used the LaTeX fragment shown below.

```{r}
simpleTeX
```

The `grid.latex()` function has three tasks to perform in order to
draw that LaTeX fragment in R:

**Authoring:**

: The LaTeX fragment has to be turned into a complete
  LaTeX document.

: The `author()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code
  takes the LaTeX fragment `tex` and produces a complete LaTeX
  document that is ready to typeset.
  

```{r}
simpleDoc <- author(simpleTeX)
simpleDoc
```

**Typesetting:**

: The LaTeX document has to be typeset to produce a set of 
  glyphs and their positions.

: The `typeset()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code takes the LaTeX document `doc` and
  produces a `"DVI"` object that contains instructions that specify the fonts to
  use (lines that contain `x_fnt_def` and `fnt_num` in the output below), 
  the glyphs to use from those fonts (lines that contain
  `x_glyph` in the output below), and where to draw those glyphs
  (lines that contain `down` and `right` and `x_glyph`).
  The output shown below has been trimmed to make it easier to read.

```{r typeset, echo=FALSE}
simpleDVI <- typeset(simpleDoc)
```
```{r dvi, echo=FALSE, eval=FALSE}
simpleDVI
```  
```{r eval=FALSE}
<<typeset>>
<<dvi>>
```
```{r echo=FALSE}
output <- capture.output(simpleDVI)
firstDown <- grep("^down", output)[1]
firstDef <- grep("^x_fnt_def", output)[1]
firstGlyph <- grep("^x_glyph", output)[1]
cat(c(output[1:firstDown], 
      "\n...\n",
      output[(firstDef - 1):(firstGlyph + 3)],
      "\n...\n"), sep="\n")
```

**Rendering:**

: The result of the typesetting step has to be drawn in R.

: The `grid.dvi()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the code below renders the typesetting information in `dvi`
  in R.  The resulting image is shown below the code.

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.dvi(simpleDVI)
```

One detail about the output above is that the rendered text from this
`grid.dvi()` call is 
smaller and in a different font from the example in the previous section
that was produced by a `grid.latex()` call.
This reflects the fact that `grid.latex()` respects the font family and
font size that are in effect when the text is rendered.
By contrast, the `grid.dvi()` call is drawing typeset information 
from a LaTeX document that just makes use of the default LaTeX font,
Computer Modern (or to be more precise, a modernised version called
Latin Modern) at 10pt.

# LaTeX packages

The code examples so far have dealt with relatively simple fragments of 
LaTeX code that consist of just text plus some simple mathematical expressions.
While this is already useful, it barely scratches the surface of 
what is possible with
LaTeX code.
Many additional effects can be obtained with LaTeX code by loading
LaTeX packages.  As a simple example, changes in text colour
requires loading the LaTeX package `xcolor`.
These packages can be loaded using the `packages` argument of the 
`grid.latex()` function (or the `element_latex()` or `geom_latex()` functions).
For example, the following code draws text with the last two
words in red.  

```{r}
colourTeX <- r"(We combine to get the \color{red}{Fitness Function})"
```

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.latex(colourTeX, packages="xcolor")
```

The argument `packages="xcolor"` is used in the authoring step to load the
package in the LaTeX document preamble.  This is demonstrated below
with an explicit call to the `author()` function, which adds 
`\usepackage{xcolor}` to the LaTeX document.

```{r}
colourDoc <- author(colourTeX, packages="xcolor")
colourDoc
```

This in turn affects the typesetting step:  without the `xcolor` package, the
`\color` command would not be recognised;  with the `xcolor` package, 
the `\color` command produces instructions to change colour 
in the `"DVI"` output.  This is demonstrated below with an
explicit call to the `typeset()` function.  An example of the colour-change
instructions is the line containing `color push` in the output below the code.

```{r colortypeset, echo=FALSE}
colourDVI <- typeset(colourDoc)
```
```{r colordvi, echo=FALSE, eval=FALSE}
colourDVI
```  
```{r eval=FALSE}
<<colortypeset>>
<<colordvi>>
```
```{r echo=FALSE}
output <- capture.output(colourDVI)
firstDef <- grep("^x_fnt_def", output)[1]
firstRGB <- grep("rgb", output)[1]
cat(c(output[1:3], 
      "\n...\n",
      output[firstDef:(firstDef + 4)],
      "\n...\n",
      output[(firstRGB - 1):(firstRGB + 2)],
      "\n...\n"),
    sep="\n")
```

The argument `packages="xcolor"` is also 
used in the rendering step because, without it,
the rendering would not take any notice of the instructions to
change colour.  This is demonstrated below with an explicit
call to the `grid.dvi()` function.  The resulting image differs from
the previous one because it uses the default LaTeX font, but we can see the
change in colour.

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.dvi(colourDVI, packages="xcolor")
```

There are several LaTeX packages with predefined support in the
`xdvir` package, including 
`xcolor` for changes in colour and `fontspec` for changes in font.
Support can be added for other LaTeX packages with the
`LaTeXpackage()` function.  We will see an example of defining a new LaTeX
package in a later section.

# Justifying text

By default, the LaTeX text drawn by `grid.latex()`
is centred upon a specified location.
For example, the following code draws the `tex` fragment vertically centred
at a location half-way up the image (as indicated by the grey line).

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.latex(simpleTeX, y=.5)
```

We can specify a different justification using the `vjust` argument.
For example, the following code draws the same `tex` fragment
at the same location, but with a bottom-justification.
Notice that the bottom of the text is based on the bounding box 
of the text, so the bottom of the text is the bottom of the subscript "i".

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.latex(simpleTeX, y=.5, vjust="bottom")
```

In some situations it will be much more useful to
justify text relative to the text baseline, as shown by the following code.  

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.latex(simpleTeX, y=.5, vjust="baseline")
```

The `xdvir` package has a very simple algorithm for determining the text 
baseline, but there is predefined support for the LaTeX package `preview`, 
which produces a more reliable baseline.  That baseline can be accessed,
assuming the `preview` package is loaded, by
specifying `vjust="preview-baseline"`.

There is also an `hjust` argument for horizontal justification.
This accepts the standard values, `"left"`, `"centre"`, and `"right"`, but
also accepts `"bbleft"`, `"bbcentre"`, and `"bbright"`.
The latter three are based on a bounding box around the actual ink 
that is drawn, which does not include space before or after glyphs 
(left-side bearing and right-side bearing).
The following code provides a demonstration of the difference
by drawing the simple LaTeX fragment from previous examples as the title
of a ggplot2 plot.
We add a (mathematical) vertical bar to the end of the LaTeX fragment
and draw the title larger than normal and justify the text against the
right side of the plot region, using `"right"` justification first and
then using `"bbright"` justification.
The output below the code just shows the very top of the plot to save
space.

```{r}
rightBearingTeX <- paste0(simpleTeX, "$|$")
```
```{r justright, eval=FALSE}
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="right"))
```
```{r echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=1, dpi=300}
pushViewport(viewport(height=100, y=1, just="top"))
gg1 <- 
<<justright>>
print(gg1, newpage=FALSE)
```
```{r justbbright, eval=FALSE}
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="bbright"))
```
```{r echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=1, dpi=300}
pushViewport(viewport(height=100, y=1, just="top"))
gg2 <- 
<<justbbright>>
print(gg2, newpage=FALSE)
```

The difference between the two plots is that the second vertical bar is
precisely aligned with the right edge of the plot region whereas the
first vertical bar is slightly to the left of the right edge of the plot
region (because of the right-side bearing of the vertical bar glyph).
This is a very small detail, but it is something that can be visually 
jarring if we are trying to align components of a plot in order
to produce a clean design.  This fine level of control is exactly 
the sort of precision that we are seeking by working with LaTeX typesetting.

# Integrating text

Text justification is a simple example of a larger problem:
text integration.  For example,
the text annotation in Figure \@ref(fig:typesetting)
is integrated with the plot in the sense that it is positioned
relative to the plot region.  In fact, closer inspection reveals
that it is carefully top-justified with the maximum y-value of the thick
red line and right-justified with the maximum x-value of the red line.

Put in terms of *integration* rather than justification, 
the text annotation in Figure \@ref(fig:typesetting)
is integrated with the plot because the LaTeX text is drawn at a location
that is coordinated with the location of other drawing in the plot.

Another example of integration, that reverses the roles, is coordinating
other drawing with the location of the LaTeX text.
The following code provides a simple example.
The LaTeX fragment is the simple one from previous examples with
two additions:  there are `\savepos` commands to mark specific locations
within the text and associate them with labels (`"a"` and `"b"`);
and there are `\xdvirzmark` commands to export those
locations for R to see.

```{r}
zrefTeX <- r"(We move the original\zsavepos{a} mean to \zsavepos{b}$\bar z_i$
\xdvirzmark{a}\xdvirzmark{b})"
```

If we render this LaTeX fragment, we just get the familiar output.
The commands that we added to the LaTeX fragment
are based on the LaTeX package `zref`,
so we must load that package.

```{r zreftex, eval=FALSE}
grid.rect()
grid.latex(zrefTeX, packages="zref")
```

```{r, echo=FALSE, fig.width=3, fig.height=.5}
<<zreftex>>
```

However, we can now access the special locations using the
`getMark()` function from the `xdvir` package.
For example, the following code accesses location `"a"` and draws 
a small red dot at that location.

```{r geta, eval=FALSE}
a <- getMark("a")
grid.circle(a$devx, a$devy, r=unit(.5, "mm"), gp=gpar(col=2, fill=2))
```

```{r, echo=FALSE, fig.width=3, fig.height=.5}
<<zreftex>>
<<geta>>
```

The following code accesses location `"b"` and draws a curved arrow
from `"a"` to `"b"`.

```{r getb, eval=FALSE}
b <- getMark("b")
grid.xspline(unit.c(a$devx, .5*(a$devx + b$devx), b$devx),
             unit.c(a$devy, a$devy - unit(3, "mm"), a$devy),
             shape=-1, gp=gpar(col=2, fill=2),
             arrow=arrow(length=unit(2, "mm"), type="closed"))
```

```{r, echo=FALSE, fig.width=3, fig.height=.5}
<<zreftex>>
<<geta>>
<<getb>>
```

The exported locations also produce "anchors" for justifying 
the LaTeX text.  For example, the following code
draws the simple LaTeX fragment with position `"a"` at 
the centre of the image (which is indicated by grey lines).

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
grid.segments(.5, 0, .5, 1, gp=gpar(col="grey"))
grid.latex(zrefTeX, packages="zref", hjust="a", vjust="a")
```

Figure \@ref(fig:zref) provides a more realistic demonstration.
This figure shows the plot from Figure \@ref(fig:typesetting)
with a line added to visually connect the thick red line with 
the red part of the LaTeX annotation.
The code for this plot is not shown for reasons of space, but it 
makes use of the same basic idea as the code above.
The full code is available in the supplementary materials for this article.

```{r, echo=FALSE}
markStr <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the 
\textcolor{Rred}{\bf \zsavepos{left}fitness function\zsavepos{right}}.
\xdvirzmark{left}\xdvirzmark{right}
\end{minipage})"
```

```{r, zref, echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=4.5, dpi=300, fig.cap="The `ggplot2` plot from Figure 1, including the LaTeX annotation, with a line added relative to marked locations within the LaTeX annotation (and relative to the thick red line)."}
markTeX <- function(data, coords) {
    latexGrob(markStr, packages=list(adventor, "xcolor", "zref"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL,
              texFile="typesetting.tex")
}

makeContent.markCurve <- function(x) {
    ## Delay this calculation until drawing time so that we
    ## are in the correct viewport
    devLoc <- deviceLoc(x$x, x$y)
    addMark("curve", devLoc$x, devLoc$y)
    x
}

markCurve <- function(data, coords) {
    gTree(x=unit(coords$x[data$x == 4], "npc"),
          y=unit(coords$y[data$x == 4], "npc"),
          cl="markCurve")
}

ggIntro + 
    grid_panel(markTeX, aes(x, y)) +
    grid_panel(markCurve, aes(x, y))

left <- getMark("left")
right <- getMark("right")
curve <- getMark("curve")

grid.lines(unit.c(curve$devx, left$devx, right$devx),
           unit.c(curve$devy, left$devy - unit(1, "mm"),
                  right$devy - unit(1, "mm")),
           gp=gpar(col=2))
```

# LaTeX graphics

The examples so far have demonstrated combining LaTeX text with general
graphics---lines and circles and so on---drawn by R.
It is also possible to use LaTeX to draw general graphics,
in particular the LaTeX package `TikZ` provides very powerful and flexible
graphics facilities.
The `xdvir` package provides support for the LaTeX package `TikZ`,
so we are able to draw `TikZ` graphics in R.

For example, the following LaTeX code describes a `TikZ` picture

```{r tikztex}
tikzTeX <- r"(%
\path (0, 0) node[circle,minimum size=.5in,fill=blue!20,draw,thick] (x) {\sffamily{R}} 
       (3, 0) node[circle,minimum size=.5in,fill=blue!20,draw,thick] (y) {Ti{\it k}Z!};
\draw[-{stealth},thick] (x) .. controls (1, 1) and (2, 1).. (y);
\draw[-{stealth},thick] (y) .. controls (2, -1) and (1, -1) .. (x);)"
```

The following code draws this `TikZ` picture in R.
The `packages="tikzPicture"` is necessary to ensure that the `TikZ` package
is loaded in the authoring step and that R takes notice of the `TiKZ`
output in the rendering step.

```{r fig.width=3, fig.height=1}
grid.rect()
grid.latex(tikzTeX, packages="tikzPicture")
```

The label on the x-axis of Figure \@ref(fig:geomlatex) 
is another simple `TikZ` picture that
uses `TikZ` commands to draw the greek letter mu
within a circle.
This example is not completely trivial because it uses the
LaTeX concept of "phantom" text to make the circle large enough to fit
a capital "M" even though no such character is drawn.
This is another example of the detailed typsetting capabilities
that access to LaTeX provides.

```{r}
<<tikzmu>>
```

The LaTeX code this time includes and explicit `\begin{tikzpicture}`
and `\end{tikzpicture}`, which were implicitly added in the previous
example because we specified `packages="tikzPicture"`.
This time, we just specify `packages="tikz"`.

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.latex(muDot, packages="tikz")
```

# Thomas Rahlf example

**Seeking permission to use this in an official article**

(ref:rahlfFigCap) This plot is an adaptation of Figure 4.1 from Thomas Rahlf's book "Data Visualisation with R".

```{r, rahlf, echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=12, fig.height=9, dpi=300, fig.cap='(ref:rahlfFigCap)', fig.keep="last"}
rahlfTeX <- paste(readLines("TeX/rahlf.tex"), collapse="\n")
source("scripts/rahlf-plot.R")
library(gridGraphics)
grid.echo()
downViewport("graphics-window-1-1")
## Add LuaTeX typeset text
multicolPackage <- LaTeXpackage("multicol",
                                preamble="\\usepackage{multicol}")
grid.latex(rahlfTeX, texFile="TeX/rahlf-doc.tex",
           packages=list(multicolPackage,
                         fontspecPackage("Lato Light")),
           x=unit(1, "cm"), y=unit(14000, "native"), 
           hjust="left", vjust="top", gp=NULL)
```

uses gp=NULL

fancy 

uses gridGraphics

# Fancy annotated equation example [@schneider2023]

+ NOTE that this nicely uses {ggtext} for simpler annotations, but
  has to go to LaTeX for fancy stuff
  => exactly the justification for {xdvir}

+ NOTE this is also an example of writing new LaTeXpackage()

```{r echo=FALSE}
library(ggtext)
library(signs)
```

```{r echo=FALSE}
## Set up "data"
mu <- 100
sigma <- 15
plot_height <- dnorm(mu, mu, sigma)
lb <- -4 * sigma + mu
ub <- 4 * sigma + mu
```

```{r echo=FALSE}
## Set up main plot
## NOTE need some data for grid_panel() to be called at all
gg <- ggplot(data.frame(x=160, y=dnorm(mu, mean=mu, sd=sigma))) +
    stat_function(fun=function(x) dnorm(x, mean=mu, sd=sigma),
                  geom="area",
                  n=1000,
                  fill="dodgerblue",
                  alpha=.5) +
    theme_classic(base_family="Roboto Condensed",
                  base_size=18) +
    theme(axis.text.x=element_markdown(),
          axis.title.x=element_markdown(),
          axis.line=element_blank())  +
    scale_x_continuous("Observed Score *X*<br>*z*",
                       breaks=seq(lb, ub, sigma),
                       limits=c(lb, ub),
                       labels=function(x)
                           paste0(signs(x),
                                  "<br>",
                                  ifelse(x == mu,
                                         "<em>&mu;</em>",
                                         paste0(signs((x - mu) / sigma,
                                                      add_plusses=T,
                                                      label_at_zero="none"),
                                                "<em>&sigma;</em>")))) +
    scale_y_continuous(NULL,
                       limits=c(0, plot_height),
                       expand=expansion(),
                       breaks=NULL) 
```

```{r echo=FALSE}
## Add {xdvir} annotation
library(xdvir)
library(gggrid)

annotateEquations <-
    LaTeXpackage(name="annotate",
                 preamble="\\usepackage{annotate-equations/annotate-equations}")
registerPackage(annotateEquations)
roboto <-
    LaTeXpackage(name="roboto",
                 preamble="\\usepackage[sfdefault,condensed]{roboto}")
registerPackage(roboto)
tikzNoBBox <-
    tikzPackage(name="tikzNoBBox", bbox=FALSE)
registerPackage(tikzNoBBox)

pkgs <- c("xcolor", "tikzNoBBox", "annotate", "roboto")

schneiderTeX <- author(readLines("TeX/schneider.tex"), packages=pkgs)
dvi <- typeset(schneiderTeX, texFile="TeX/schneider-doc.tex")

annotation <- function(data, coords) {
    dviGrob(dvi, packages=pkgs,
            x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
            y=coords$y, hjust=1, vjust=1)
}

gg +
    grid_panel(annotation, aes(x=x, y=y))
```

# Anzjs example 

```{r, anzjs, echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=8, fig.height=4.5, dpi=300, fig.cap='Based on Fig 10 from ANZJS'}
source("scripts/anzjs.R")
```

# RTL or Vertical layout example?

# gggrid

Need a \CRANpkg{gggrid} package 
[@pkg-gggrid] example.

# Customisation

Skip the authoring step by writing LaTeX document yourself

Skip the typesetting step by generating DVI output yourself

Experts only!

# Discussion

Must acknowledge tikzDevice package !!!

Comparison to importing (e.g., the import-svg approach of schneider).
Can refer way back to including pngs of tex in html!?

Owe big debt to the \CRANpkg{tinytex} package,
which simplifies the calling of TeX engines, installation
of TeX packages (and TeX itself),
and running TeX multiple times when necessary (e.g., for TikZ
position tracking).

# Acknowledgements

Thanks to Marc-Olivier Beausoleil for permission to base the visualisation
in Figure \@ref(fig:typesetting) on his work.

# Summary

