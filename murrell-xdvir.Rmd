---
title: "Rendering LaTeX in R"
date: "2025-01-23"
abstract: >
  The xdvir package provides functions for rendering 
  LaTeX code as labels, annotations, and
  data symbols in R plots.  There are convenient high-level
  functions for rendering LaTeX fragments, including
  labels on ggplot2 plots, plus lower-level
  functions for more fine control over the authoring,
  typesetting, and rendering of LaTeX code.
  There is support for making use of LaTeX packages,
  including TikZ graphics. 
  The rendered
  LaTeX output is fully integrated with R graphics output
  in the sense that LaTeX output 
  can be positioned relative to R graphics output and vice versa.
draft: true
author:  
  - name: Paul Murrell
    affiliation: The University of Auckland
    address:
    - Department of Statistics
    - Auckland, New Zealand
    email: paul@stat.auckland.ac.nz
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
type: package
output: 
  rjtools::rjournal_pdf_article:
    toc: no
  rjtools::rjournal_web_article:
    self_contained: yes
    toc: no
bibliography: murrell-xdvir.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
options(xdvir.engine="xetex")
```

```{r pdf-graphics, echo=FALSE, eval=knitr::is_latex_output()}
knitr::opts_chunk$set(dev="cairo_pdf")
```

```{r html-graphics, echo=FALSE, eval=knitr::is_html_output()}
knitr::opts_chunk$set(dev="png", dev.args=list(type="cairo-png"))
```

# Introduction

Text labels, titles, and annotations are essential components of 
any data visualization.  Viewers focus a lot of their attention
on text [@massvis], 
text is the most effective way to communicate some types of 
information [@hearst],
and the message obtained from a data visualization can be
heavily influenced by the text on a plot [@kong].

R provides relatively flexible tools for adding text labels to plots.
For example, in the `graphics` package, we can specify an
overall plot title and axis titles via the `main`,
`xlab`, and `ylab` arguments to the `plot()` function
and we can add text at arbitrary locations on the plot with the `text()` 
and `mtext()` functions.

Unfortunately, these core tools for drawing text are quite limited
in terms of the formatting of the text.
For example, there is no facility for emphasising an individual word using
a **bold** or *italic* face within a text label.

The \CRANpkg{gridtext} [@pkg-gridtext] and \CRANpkg{ggtext} [@pkg-ggtext]
packages greatly improved the situation by allowing text labels
to include a small subset of
markdown and HTML (plus CSS).  This allowed changes in font face
and color within text labels.

More recently, the \CRANpkg{marquee} package [@pkg-marquee]
improved the situation a great deal further by providing full support for
markdown within text labels.  This made it possible to layout more
complex arrangements of text and graphical content within text labels.

However, despite these advances, there are still some text formatting tasks that
remain out of reach.  For example, Figure \@ref(fig:typesetting) 
shows a plot with a text annotation in the top-right corner that contains
a combination of features that cannot be produced using the 
available text-drawing tools.

```{r echo=FALSE}
## Parameter for plotting
## Set x variable for the fitness function 
x <- seq(-1, 7.5, by = .01)

## Math parameters for Fitness function 
s <- .5
m <- 1.5
t <- 1.7
u <- 3.4
div1 <- 2.4
div2 <- 3.5

## Set population parameters
## NB individuals, try with 10, and 1000 
n <- 1000 
## Get fake phenotypes
## Phenotypes for the population
pheno <- rnorm(n = n, mean = 3.2, sd = 0.5) 
## Make y height just for vizualisation purpose 
fit <- rnorm(length(pheno), mean = .12, sd =.01)


## Load functions ----------------------------------------------------------
## Mathematical fitness function (2 peaks )
## This is a speculative fitness function, you could design your own.
fit.function  <- function(x, s, m, t, u, div1 = 2, div2 = 2.5) {
    exp(-s^(-2)*(x-m)^(2))/div1+exp(-t^(-2)*(x-u)^(2))/div2
}

y <- fit.function(x = x,s = s, m = m,t = t,u = u, div1 = div1, div2 = div2)

main.plot <- function(mar = c(3, 3, .25, .25), col = 2) {
    ## Set parameter of plotting area 
    par(mar = mar)
    ## Plot fitness function 
    plot(y ~ x, 
         xlim = c(-0.5, 7),
         ylim = c(0, .7),
         axes=FALSE,
         type = "l", lwd = 5, col = col, 
         ylab = "Fitness", xlab = "Phenotypes")
    axis(1)
    axis(2, at=seq(0, .6, .2))
    box()
}

dens.xy <- density(x = pheno, n = 512, adjust = 2) # Adjust to make it smoother 

## Make a fake population 
add.fake.pop <-  function(x = dens.xy, y = fit,  alp = 1) {
    ## Line at the mean 
    ## abline(v = mean(x), lty = 3)
    ## Calculate the density of the population 
    ## Add density 
    lines(x = dens.xy$x, y = dens.xy$y/3, lty = 2)
}

drawPlot <- function() {
    par(family="TeX Gyre Adventor", mgp=c(2, .7, 0))
    main.plot()
    add.fake.pop(alp = .1)
}
```

```{r, echo=FALSE}
annotationTeX <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the \textcolor{Rred}{\bf fitness function}.
\end{minipage})"
```

```{r, typesetting, echo=FALSE, fig.width=7, fig.height=4.5, out.width="100%", fig.keep="last", fig.cap="A plot with a text annotation that contains several typesetting challenges:  in-line mathematical equations; changes in color; and automated line-breaks with full justification and hyphenation."}

library(xdvir)
adventor <- fontspecPackage(font="TeX Gyre Adventor", name="adventor")

library(gggrid)

ggIntro <- ggplot(data.frame(x, y)) +
    geom_line(aes(x, y), linewidth=2, colour=2) +
    geom_line(aes(x, y), data=data.frame(x=dens.xy$x, y=dens.xy$y/3),
              linetype="dashed") +
    xlab("Phenotypes") +
    ylab("Fitness") +
    theme_bw() +
    theme(text=element_text(family="TeX Gyre Adventor", size=12),
          panel.grid=element_blank())

label <- function(data, coords) {
    latexGrob(annotationTeX, packages=list(adventor, "xcolor"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL)
}

ggIntro + 
    grid_panel(label, aes(x, y))
```

The annotation in Figure \@ref(fig:typesetting)
may not appear to be particularly special nor particularly complicated 
at first glance, but it harbors several important details:

* The text is a mixture of plain text and mathematical expressions (like
  $\bar{z}_i$). Furthermore, the mathematical expressions use a different font
  (Latin Modern) than the plain text (TeX Gyre Adventor)
  and the mixture is broken across multiple lines.

  The R graphics system can draw mathematical expressions [@plotmath]
  and that includes a mixture of plain text and mathematical expressions.
  Furthermore, the R graphics system uses a separate symbol font
  for mathematical expressions compared to plain text.  However,
  further changes in font within the plain text is not possible and line
  breaks are not supported.
  There is also the problem
  that the typesetting of mathematical expressions in R graphics is not
  of a very high quality.

* The text is not all the same color; the final two words (but not the full
  stop) are red.  Furthermore, the final two words are **bold**;
  they have a different
  font face compared to the rest of the text.

  The R graphics system can only draw a character value with a single color
  and a single font face.
  The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages make it possible to change color within
  a character value, but they do not allow a mixture of plain text and
  mathematical expressions.

* The text is broken over multiple lines. Furthermore, the text is fully
  justified (not ragged-left or ragged-right justified) and one word
  has been split across lines and hyphenated. Although it is not
  obvious from the plot itself, the line breaks were also automatically
  generated to fit the text into a fixed width (3 inches).

  The R graphics system can draw a character value across multiple lines, but
  only if explicit newlines are embedded in the character value (i.e., the line
  breaks are manual). The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages can calculate simple
  automated line breaks, but they will not break a word across lines (or
  hyphenate) and they cannot fully justify the resulting text. The
  \CRANpkg{marquee} package can automate line breaks and fully justify
  text, but it cannot hyphenate nor can it produce mathematical equations.

The features outlined above are all examples of *typesetting*; determining an
arrangement of individual characters and symbols (glyphs) that could be as
simple as placing one character after another (from left to right), but could
also be as complex as arranging mathematical symbols, splitting text into
multiple columns, or writing text vertically from top to bottom.

From R 4.3.0, it has been
possible to draw text from a set of typeset glyphs using the
functions `grDevices::glyphInfo()` and `grid::grid.glyph()`
[@murrell-pedersen-urbanek-glyphs-2023]. This facility
offers the promise of being able to render arbitrary typeset text
in R. However, it
presupposes that we are able to generate a set of typeset glyphs.

The \CRANpkg{marquee} package provides an example of a package
that can generate typeset glyphs.  It is capable of converting
markdown input into a set of glyphs and their positions, which are
then rendered in R.

This article describes the `xdvir` package, which is another example
of a package that can generate typeset glyphs.
In this case, the input is LaTeX, a TeX engine is used to
generate a set of glyphs and their positions, and then the
result is rendered in R.
The benefit of the `xdvir` package is that it provides access to the
typesetting capabilities of LaTeX, which includes hyphenation,
fully justified text, mixtures of plain text and mathematical equations---all
of the features demonstrated in Figure \@ref(fig:typesetting)---and much more.

The next section describes the basic usage of the `xdvir` package.
This is followed by a section that breaks down the 
design of the `xdvir` package to show the steps that are
required to render LaTeX output in R.
Subsequent sections explore several of the complexities 
that can arise with rendering LaTeX text in R graphics and 
some of the solutions that 
the `xdvir` package provides.
The article ends with several extended examples of rendering LaTeX text in R.

# LaTeX text labels in R {#userinterface}

The simplest way to draw LaTeX text with the `xdvir` package 
is to call the `grid.latex()` function.  The first argument to
this function is a character value, which is interpreted as
a fragment of LaTeX code.
For example, the following code draws a text label that contains
a fragment of the larger annotation from 
Figure \@ref(fig:typesetting).  We use just a fragment here in order
to keep the code readable.

Because LaTeX code tends to contain 
a large number of backslashes, the code below uses the `r"(...)"`
syntax for raw character constants, so that we do not have to
escape each backslash with a double backslash.
The resulting image is shown below the code.
Although it is not immediately obvious from that image, 
the text, or rather the glyphs, in the image are rendered by R.

```{r}
library(xdvir)
```

```{r, fragment}
simpleTeX <- r"(We move the original mean to $\bar z_i$)"
```

```{r rect, eval=FALSE, echo=FALSE}
grid.rect()
```
```{r gridlatex, eval=FALSE}
grid.latex(simpleTeX)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<gridlatex>>
```

It is possible to produce something similar to this result using 
the "plotmath" feature in R, as shown in the following code (and the image
below the code).  However, this demonstrates that
one advantage of using `xdvir`, even for a simple
piece of text like this, is the superior quality of the LaTeX 
fonts and typesetting for mathematical expressions.

```{r}
plotmath <- expression("We move the original mean to "*bar(italic(z))[i])
```
```{r plotmathexpr, eval=FALSE}
grid.text(plotmath)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<plotmathexpr>>
```

Another immediate benefit of `xdvir` is that we can automatically fit
the text within a specified width.
For example, the following code draws the LaTeX fragment `tex`
again, but this time forces it to fit within a column that is half
the width of the image.

```{r width, eval=FALSE}
grid.latex(simpleTeX, width=.5)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<width>>
```

As the function name `grid.latex()` suggests, that function
produces low-level 
drawing in the `grid` package graphics system.
The text is just drawn relative to the current `grid` viewport,
wherever that may be on the page.
While this is extremely flexible, it is more likely that 
we want to combine and coordinate the text with a high-level plot
of some sort, like the annotation in Figure \@ref(fig:typesetting).
There are various ways that low-level `grid` drawing can be combined
with a high-level plot, but we will leave those demonstrations to
later sections.

Instead, for now, we will demonstrate a more common scenario:
drawing LaTeX text labels on a \CRANpkg{ggplot2} plot [@pkg-ggplot2].
For this purpose, the `xdvir` package provides the
`element_latex()` function.  This allows us to specify a LaTeX fragment
as a plot label and we can indicate the special nature of the label
via the `ggplot2::theme()` function.

For example, the following code uses the same LaTeX fragment 
from the example above as the title of a \CRANpkg{ggplot2} plot.
The resulting plot is shown in Figure \@ref(fig:elementlatex).
One detail about this result is that the text in this title is larger 
than the text drawn by the call to `grid.latex()` above.
A closer inspection reveals that the font is also different.
This reflects the fact that `grid.latex()` and `element_latex()`
respect the graphical parameter settings---font families and font sizes---that
are in effect when the LaTeX fragment is drawn.  In Figure
\@ref(fig:elementlatex) that means respecting the theme settings
of the \CRANpkg{ggplot2} plot.

The `ggIntro` object in the code below
contains a description of the main \CRANpkg{ggplot2} 
plot from Figure 
\@ref(fig:typesetting).
The code for generating 
`ggIntro` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

```{r}
library(ggplot2)
```

(ref:elementlatexFigCap) The `ggplot2` plot from Figure \@ref(fig:typesetting), without the text annotation, but with a title that was specified using a LaTeX fragment and the function `element_latex()`.

```{r, elementlatex, fig.width=7, fig.height=4.5, out.width="100%", fig.cap='(ref:elementlatexFigCap)'}
ggIntro +
    labs(title=simpleTeX) +
    theme(plot.title=element_latex())
```

The `xdvir` package also provides a `geom_latex()` function for
drawing text labels, similar to the standard `ggplot2::geom_text()` function.
The values specified for the 
`label` aesthetic for `geom_latex()` are treated as fragments of LaTeX
code.
For example, the following code draws a plot with a set of red points
and a set of red labels, one for each point.
The result is shown in Figure \@ref(fig:geomlatex).

The points are drawn using the standard `ggplot::geom_point()` function,
but the labels are drawn using `geom_latex()` from the `xdvir` package.
The red labels for the red points in Figure \@ref(fig:geomlatex)
are small LaTeX fragments that each describe 
a simple LaTeX mathematical expression, as shown below.

```{r tikzmu, echo=FALSE}
muDot <- r"(%
\begin{tikzpicture}
\node[draw,circle,thick,inner sep=0.5mm]{\vphantom{M}$\mu$};
\end{tikzpicture})"
```
```{r echo=FALSE}
samples <- data.frame(x=rnorm(50), sample=rep(1:5, each=10))
means <- aggregate(samples$x, list(sample=samples$sample), mean)
means$label <- paste0("$\\bar x_", means$sample, "$")
```

```{r}
means$label
```

```{r, echo=FALSE, message=FALSE}
ggGeom <- ggplot(samples) +
    geom_vline(xintercept=0, linetype="solid", colour=1, linewidth=.5) +
    geom_point(aes(x, sample), colour="grey", size=4, alpha=.5) +
    xlab(NULL) +
    scale_x_continuous(breaks=0, labels=muDot) +
    scale_y_continuous(breaks=1:5, expand=expansion(.25)) +
    theme_minimal() +
    theme(axis.text.x=element_latex(size=16, packages="tikz", 
                                    margin=margin(-3, 0, 0, 0)),
          axis.ticks.x=element_blank(),
          axis.title.y=element_text(colour="grey"),
          axis.text.y=element_text(colour="grey"),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.x=element_blank(),
          panel.grid.minor.y=element_blank())
```

The `ggGeom` object in the code below describes the 
main plot, consisting of gray dots, horizontal and vertical lines,
and y-axis labels.
The code for generating 
`ggGeom` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

(ref:geomlatexFigCap) A `ggplot2` plot with text labels drawn using `geom_latex()`.

```{r, geomlatex, fig.width=7, fig.height=3.5, out.width="100%", fig.cap='(ref:geomlatexFigCap)'}
ggGeom +
    geom_point(aes(x, sample), data=means, colour=2, size=4) +
    geom_latex(aes(x, sample, label=label), data=means, 
               size=6, vjust=-.4, colour=2)    
```

# Under the hood {#underhood}

The previous section showed that simple usage of the `xdvir` package
only requires specifying a LaTeX fragment as the text to draw.
For example, the examples used the LaTeX fragment shown below.

```{r}
simpleTeX
```

The `grid.latex()` function has three tasks to perform in order to
draw that LaTeX fragment in R:

**Authoring:**

: The LaTeX fragment has to be turned into a complete
  LaTeX document.

: The `author()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code
  takes the LaTeX fragment `simpleTeX` and produces a complete LaTeX
  document that is ready to typeset.
  

```{r}
simpleDoc <- author(simpleTeX)
simpleDoc
```

**Typesetting:**

: The LaTeX document has to be typeset to produce a set of 
  glyphs and their positions.

: The `typeset()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code takes the LaTeX document `doc` and
  produces a `"DVI"` object that contains instructions that specify the fonts to
  use (lines that contain `x_fnt_def` and `fnt_num` in the output below), 
  the glyphs to use from those fonts (lines that contain
  `x_glyph` in the output below), and where to draw those glyphs
  (lines that contain `down` and `right` and `x_glyph`).
  The output shown below has been trimmed to make it easier to read.

```{r typeset, echo=FALSE}
simpleDVI <- typeset(simpleDoc)
```
```{r dvi, echo=FALSE, eval=FALSE}
simpleDVI
```  
```{r eval=FALSE}
<<typeset>>
<<dvi>>
```
```{r echo=FALSE}
output <- capture.output(simpleDVI)
firstDown <- grep("^down", output)[1]
firstDef <- grep("^x_fnt_def", output)[1]
firstGlyph <- grep("^x_glyph", output)[1]
cat(c(output[1:firstDown], 
      "\n...\n",
      output[(firstDef - 1):(firstGlyph + 3)],
      "\n...\n"), sep="\n")
```

**Rendering:**

: The result of the typesetting step has to be drawn in R.

: The `render()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the code below renders the typesetting information from
  the `simpleDVI` object
  in R.  The resulting image is shown below the code.

```{r simpledvi, eval=FALSE}
render(simpleDVI)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<simpledvi>>
```

One detail about the output above is that the rendered text from this
`render()` call is 
smaller and in a different font compared to the example from
the previous section,
which was produced by a `grid.latex()` call.
This reflects the fact that `grid.latex()`,
in the authoring step, respects the font family and
font size that are in effect when the text is rendered.
By contrast, the `render()` call is drawing typeset information 
from a LaTeX document that just makes use of the default LaTeX font,
Computer Modern (or to be more precise, a modernized version called
Latin Modern) at 10pt.

# LaTeX packages {#packages}

The code examples so far have dealt with relatively simple fragments of 
LaTeX code that consist of just text plus some simple mathematical expressions.
While this is already useful, it barely scratches the surface of 
what is possible with
LaTeX code.

Many additional effects can be obtained with LaTeX code by loading
LaTeX packages.  As a simple example, changes in text color
requires loading the LaTeX package `xcolor`.
These LaTeX packages can be loaded using the `packages` argument of the 
`grid.latex()` function (or the `element_latex()` or `geom_latex()` functions).
For example, the following code draws text with the last two
words in red.  

```{r}
colourTeX <- r"(We combine to get the \color{red}{Fitness Function})"
```

```{r colourtex, eval=FALSE}
grid.latex(colourTeX, packages="xcolor")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<colourtex>>
```

The argument `packages="xcolor"` is used in the authoring step to load the
package in the LaTeX document preamble.  This is demonstrated below
with an explicit call to the `author()` function.  We can see that
`\usepackage{xcolor}` has been added to the LaTeX document.

```{r}
colourDoc <- author(colourTeX, packages="xcolor")
colourDoc
```

This in turn affects the typesetting step:  without the `xcolor` package, the
`\color` command would not be recognized;  with the `xcolor` package, 
the `\color` command produces instructions to change color 
in the `"DVI"` output.  This is demonstrated below with an
explicit call to the `typeset()` function.  An example of the color-change
instructions is the line containing `color push` in the output below the code.

```{r colortypeset, echo=FALSE}
colourDVI <- typeset(colourDoc)
```
```{r colordvi, echo=FALSE, eval=FALSE}
colourDVI
```  
```{r eval=FALSE}
<<colortypeset>>
<<colordvi>>
```
```{r echo=FALSE}
output <- capture.output(colourDVI)
firstDef <- grep("^x_fnt_def", output)[1]
firstRGB <- grep("rgb", output)[1]
cat(c(output[1:3], 
      "\n...\n",
      output[firstDef:(firstDef + 4)],
      "\n...\n",
      output[(firstRGB - 1):(firstRGB + 2)],
      "\n...\n"),
    sep="\n")
```

The argument `packages="xcolor"` is also 
used in the rendering step because, without it,
the rendering would not take any notice of the instructions to
change color.  This is demonstrated below with an explicit
call to the `render()` function.  The resulting image differs from
the previous one because it uses the default LaTeX font, but we can see the
same change in color for the last two words.

```{r colourdvi, eval=FALSE}
render(colourDVI, packages="xcolor")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<colourdvi>>
```

There are several LaTeX packages with predefined support in the
`xdvir` package, including 
`xcolor` for changes in color and `fontspec` for changes in font.
Support can be added for other LaTeX packages with the
`LaTeXpackage()` function.  We will see other predefined packages
and an example of defining a new LaTeX
package in later sections.

# Justifying text

By default, the LaTeX text drawn by `grid.latex()`
is centered upon a specified location.
For example, the following code draws the `tex` fragment vertically centered
at a location half-way up the image (as indicated by the gray line).

```{r horiz, echo=FALSE, eval=FALSE}
grid.segments(0, .5, 1, .5, gp=gpar(col="grey"))
```
```{r justcentre, eval=FALSE}
grid.latex(simpleTeX, y=.5)
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<justcentre>>
```

We can specify a different justification using the `vjust` argument.
For example, the following code draws the same `tex` fragment
at the same location, but with a bottom-justification.
Notice that the bottom of the text is based on the bounding box 
of the text, so the bottom of the text is the bottom of the subscript "i".

```{r justbottom, eval=FALSE}
grid.latex(simpleTeX, y=.5, vjust="bottom")
```

```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<justbottom>>
```

In some situations it will be much more useful to
justify text relative to the text baseline, as shown by the following code.  

```{r justbaseline, eval=FALSE}
grid.latex(simpleTeX, y=.5, vjust="baseline")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<justbaseline>>
```

The `xdvir` package has a very simple algorithm for determining the text 
baseline, but there is also predefined support for the LaTeX package `preview`, 
which produces a more reliable baseline.  That baseline can be accessed,
assuming the `preview` package is loaded, by
specifying `vjust="preview-baseline"`.

There is also an `hjust` argument for horizontal justification.
This accepts the standard values, `"left"`, `"centre"`, and `"right"`, but
also accepts `"bbleft"`, `"bbcentre"`, and `"bbright"`.
The latter three are based on a bounding box around the actual ink 
that is drawn, which does not include space before or after glyphs 
(left-side bearing and right-side bearing).
The following code provides a demonstration of the difference
by drawing the simple LaTeX fragment from previous examples as the title
of a ggplot2 plot.
We add a (mathematical) vertical bar to the end of the LaTeX fragment
and draw the title larger than normal and justify the text against the
right side of the plot region, using `"right"` justification first and
then using `"bbright"` justification.
The output below the code just shows the very top of the plot in order to save
space.

```{r}
rightBearingTeX <- paste0(simpleTeX, "$|$")
```
```{r justright, eval=FALSE}
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="right"))
```
```{r echo=FALSE, fig.width=7, fig.height=1, out.width="100%"}
pushViewport(viewport(height=100, y=1, just="top"))
gg1 <- 
<<justright>>
print(gg1, newpage=FALSE)
```
```{r justbbright, eval=FALSE}
ggIntro + 
    labs(title=rightBearingTeX) +
    theme(plot.title=element_latex(size=20, hjust="bbright"))
```
```{r echo=FALSE, fig.width=7, fig.height=1, out.width="100%"}
pushViewport(viewport(height=100, y=1, just="top"))
gg2 <- 
<<justbbright>>
print(gg2, newpage=FALSE)
```

The difference between the two plots is that the second vertical bar is
precisely aligned with the right edge of the plot region whereas the
first vertical bar is slightly to the left of the right edge of the plot
region (because of the right-side bearing of the vertical bar glyph).
This is a very small detail, but it is something that can be visually 
jarring if we are trying to align components of a plot in order
to produce a clean design.  This fine level of control is exactly 
the sort of precision that we are seeking by working with LaTeX typesetting.

# Integrating text

Justifying LaTeX text is a simple example of a larger problem:
integrating LaTeX text.  For example,
the text annotation in Figure \@ref(fig:typesetting)
is integrated with the plot in the sense that it is positioned
relative to the plot region.  In fact, closer inspection reveals
that it is carefully top-justified with the maximum y-value of the thick
red line and right-justified with the maximum x-value of the red line.

Put in terms of *integration* rather than justification, 
the text annotation in Figure \@ref(fig:typesetting)
is integrated with the plot because the LaTeX text is drawn at a location
that is coordinated with the location of other drawing in the plot.

Another example of integration, that reverses the roles, is coordinating
other drawing with the location of the LaTeX text.
The following code provides a simple example.
The LaTeX fragment is the simple one from previous examples with
two additions:  there are `\savepos` commands to mark specific locations
within the text and associate them with labels (`"a"` and `"b"`);
and there are `\Rzmark` commands to export those
locations for R to see.

```{r}
zrefTeX <- r"(We move the original\zsavepos{a} mean to \zsavepos{b}$\bar z_i$
\Rzmark{a}\Rzmark{b})"
```

If we render this LaTeX fragment, we just get the familiar output.
The commands that we added to the LaTeX fragment
are based on the LaTeX package `zref`,
so we must load that package.

```{r zreftex, eval=FALSE}
grid.latex(zrefTeX, packages="zref")
```

```{r, echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<zreftex>>
```

However, we can now access the special locations in the LaTeX output using the
`getMark()` function from the `xdvir` package.
For example, the following code accesses location `"a"`, just after
the word "original", and draws 
a small red dot at that location.

```{r geta, eval=FALSE}
a <- getMark("a")
grid.circle(a$devx, a$devy, r=unit(.5, "mm"), gp=gpar(col=2, fill=2))
```

```{r, echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<zreftex>>
<<geta>>
```

The following code accesses location `"b"`, just before the letter "z",
and draws a curved arrow
from `"a"` to `"b"`.

```{r getb, eval=FALSE}
b <- getMark("b")
grid.xspline(unit.c(a$devx, .5*(a$devx + b$devx), b$devx),
             unit.c(a$devy, a$devy - unit(3, "mm"), a$devy),
             shape=-1, gp=gpar(col=2, fill=2),
             arrow=arrow(length=unit(2, "mm"), type="closed"))
```

```{r, echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<zreftex>>
<<geta>>
<<getb>>
```

The exported locations also produce "anchors" for justifying 
the LaTeX text.  For example, the following code
draws the simple LaTeX fragment with position `"a"` at 
the center of the image (which is indicated by gray lines).

```{r justanchor, eval=FALSE}
grid.latex(zrefTeX, packages="zref", hjust="a", vjust="a")
```
```{r vert, echo=FALSE, eval=FALSE}
grid.segments(.5, 0, .5, 1, gp=gpar(col="grey"))
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<horiz>>
<<vert>>
<<justanchor>>
```

Figure \@ref(fig:zref) provides a more realistic demonstration.
This figure shows the plot from Figure \@ref(fig:typesetting)
with a line added to visually connect the thick red line with 
the red part of the LaTeX annotation.
The code for this plot is not shown for reasons of space, but it 
makes use of the same basic idea as the code above by saving locations within
the LaTeX output and then accessing them with the `getMark()` function.
The full code is available in the supplementary materials for this article.

```{r, echo=FALSE}
markStr <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the 
\textcolor{Rred}{\bf \zsavepos{left}fitness function\zsavepos{right}}.
\Rzmark{left}\Rzmark{right}
\end{minipage})"
```

(ref:zrefFigCap) The `ggplot2` plot from Figure \@ref(fig:typesetting), including the LaTeX annotation, with a line added relative to marked locations within the LaTeX annotation (and relative to the thick red line).

```{r, zref, echo=FALSE, fig.width=7, fig.height=4.5, out.width="100%", fig.cap='(ref:zrefFigCap)'}
markTeX <- function(data, coords) {
    latexGrob(markStr, packages=list(adventor, "xcolor", "zref"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL)
}

makeContent.markCurve <- function(x) {
    ## Delay this calculation until drawing time so that we
    ## are in the correct viewport
    devLoc <- deviceLoc(x$x, x$y)
    addMark("curve", devLoc$x, devLoc$y)
    x
}

markCurve <- function(data, coords) {
    gTree(x=unit(coords$x[data$x == 4], "npc"),
          y=unit(coords$y[data$x == 4], "npc"),
          cl="markCurve")
}

ggIntro + 
    grid_panel(markTeX, aes(x, y)) +
    grid_panel(markCurve, aes(x, y))

left <- getMark("left")
right <- getMark("right")
curve <- getMark("curve")

grid.lines(unit.c(curve$devx, left$devx, right$devx),
           unit.c(curve$devy, left$devy - unit(1, "mm"),
                  right$devy - unit(1, "mm")),
           gp=gpar(col=2))
```

# LaTeX graphics

The examples so far have demonstrated using LaTeX code to describe
text labels, combined with using R to draw general
graphics---lines and circles and so on.
It is also possible to use LaTeX to draw general graphics.
In particular, the LaTeX package `TikZ` provides very powerful and flexible
graphics facilities.
The `xdvir` package provides support for the LaTeX package `TikZ`,
so we are able to render `TikZ` graphics in R.

For example, the following LaTeX code describes a `TikZ` picture
consisting of two text labels enclosed within blue circles, with
arrows connecting the circles.

```{r tikztex}
tikzTeX <- r"(%
\path (0, 0) node[circle,minimum size=.5in,fill=blue!20,draw,thick] (x) {\sffamily{R}} 
       (3, 0) node[circle,minimum size=.5in,fill=blue!20,draw,thick] (y) {Ti{\it k}Z!};
\draw[-{stealth},thick] (x) .. controls (1, 1) and (2, 1).. (y);
\draw[-{stealth},thick] (y) .. controls (2, -1) and (1, -1) .. (x);)"
```

The following code draws this `TikZ` picture in R.
The argument 
`packages="tikzPicture"` is necessary to ensure that the `TikZ` package
is loaded in the authoring step, that TikZ output is produced in the
typesetting step, and that R takes notice of the `TiKZ`
output in the rendering step.

```{r tikzpicture, eval=FALSE}
grid.latex(tikzTeX, packages="tikzPicture")
```
```{r echo=FALSE, fig.width=3, fig.height=1, out.width="40%"}
<<rect>>
<<tikzpicture>>
```

The label on the x-axis of Figure \@ref(fig:geomlatex) 
is another simple `TikZ` picture that
uses `TikZ` commands to draw the Greek letter mu
within a circle.
This example is not completely trivial because it uses the
LaTeX concept of "phantom" text to make the circle large enough to fit
a capital "M" even though no such character is drawn.
This is another example of the detailed typsetting capabilities
that access to LaTeX provides.

```{r}
<<tikzmu>>
```

The LaTeX code this time includes an explicit `\begin{tikzpicture}`
and `\end{tikzpicture}`, which were implicitly added in the previous
example because we specified `packages="tikzPicture"`.
This time, we just specify `packages="tikz"`.

```{r tikz, eval=FALSE}
grid.latex(muDot, packages="tikz")
```
```{r echo=FALSE, fig.width=3, fig.height=.5, out.width="40%"}
<<rect>>
<<tikz>>
```

We will see a more complex example of TikZ output in a later section.
Figure \@ref(fig:diag) is also a TikZ picture that has been rendered
in R.

# Customization and debugging
 
Most of the examples in this article take a fragment of LaTeX code
and pass it to the `grid.latex()` function, which performs an
authoring step, a typesetting step, and a rendering step.
We saw in a previous section that there are functions
`author()`, `typeset()`, and `render()`
that allow us to perform these steps separately (see Figure \@ref(fig:diag)).
This provides more control over the individual steps and allows
us to inspect the results of the individual steps, which can be
useful for debugging.
In this section, we explore further options for controlling the 
authoring, typesetting, and rendering steps.

```{r diag, echo=FALSE, fig.width=8, fig.height=3, out.width="100%", fig.cap="The design of the `xdvir` package."}
diagTeX <- readLines("diagram/diag.tex")
## Have to add the {xdvir} pgfsys-driver
diagTeX <- c(diagTeX[1], 
             paste0("\\def\\pgfsysdriver{'",
                    system.file("tikz", "pgfsys-xdvir.def",
                                package="xdvir"),
                    "'}"),
             diagTeX[-1])
diagDVI <- typeset(diagTeX)
## Have to load the TikZ package
grid.newpage()
grid.dvi(diagDVI, packages="tikz")
```

The `author()` function transforms a LaTeX fragment into a 
complete LaTeX document.  Although there are arguments to the `author()`
function that allow some control over that transformation,
e.g., the `packages` argument, it does not allow full control
over the composition of the LaTeX document.
Fortunately, a LaTeX document within R is essentially just a character vector,
so another way to author a LaTeX document is to create an external text file
and read that into R.  This allows complete control over the content
of the LaTeX document.
Another possibility is that we want to use a LaTeX document that
we did not create, for example, if we write Markdown code and 
convert it to LaTeX code.  We will see an example of this in a later section.

The `typeset()` function transforms a LaTeX document into a `"DVI"` object
that contains a set of typeset glyphs.  There is limited control over this
process as well, with only the `engine` argument allowing us to select between
`"xetex"` or `"luatex"`.  Again, one option to 
obtain greater control is to 
performing this step outside of R by running
a TeX engine, e.g., `xelatex`, on an external text file to produce a DVI
file.  The `xdvir` package provides the `readDVI()` function
to read external DVI files into R and these can then be passed to
the `render()` function for drawing.

One important caveat is that a `"LaTeXdocument"` object that is produced by
the `author()` function, and a `"DVI"` object that is produced by the 
`typeset()` function, contains information about how it was created,
for example, the TeX `engine` that was specified.
The `typeset()` function checks this information and warns if we ask
to typeset a `"LaTeXdocument"` that was produced for a different TeX engine.
Similarly, the `render()` function, which also has an `engine` argument,
checks and warns if we ask to render a
`"DVI"` object that was produced using a different TeX engine.

External LaTeX documents and DVI files do not (explicitly) contain this
information so it is up to the user to ensure that the TeX engine,
and any LaTeX packages, are consistent with the arguments provided
to the functions `typeset()` and `render()`.
In some situations, even with the appropriate level of care,
it will be impossible to avoid warnings.

# Example 1

```{r echo=FALSE}
source("scripts/rahlf-plot.R")
```
```{r rahlfplot, echo=FALSE, eval=FALSE}
rahlfPlot()
```

```{r gridgraphics, echo=FALSE, eval=FALSE}
library(gridGraphics)
grid.echo()
```

```{r downvp, echo=FALSE, eval=FALSE}
downViewport("graphics-window-1-1")
```

```{r echo=FALSE}
rahlfTeX <- paste(readLines("TeX/rahlf.tex"), collapse="\n")
```

```{r multicol, echo=FALSE, eval=FALSE}
multicol <- LaTeXpackage("multicol",
                         preamble="\\usepackage{multicol}")
registerPackage(multicol)
```

```{r rahlflatex, echo=FALSE, eval=FALSE}
grid.latex(rahlfTeX, 
           packages=c("fontspec", "multicol"),
           x=unit(1, "cm"), y=unit(14000, "native"), 
           hjust="left", vjust="top")
```

This section demonstrates a more complete example of rendering LaTeX text
within a plot.  The plot, shown in Figure \@ref(fig:rahlf), 
provides a clear example of the more advanced typesetting 
capabilities of LaTeX;  the text annotation in the top-left corner
of the plot is not only typeset into two columns,
but both columns are fully justified and feature several examples of
hyphenation.

This example also demonstrates one way to integrate a
`grid.latex()` call with a plot that was drawn using functions
from the `graphics` package.  We will also see a simple 
demonstration of the `LaTeXpackage()` function to allow use of 
a LaTeX package that has no predefined support in `xdvir`.

(ref:rahlfFigCap) A plot with a two-column text annoation. This plot is an adaptation of Figure 4.1 from Thomas Rahlf's book "Data Visualisation with R" [@rahlf].

```{r, rahlf, echo=FALSE, fig.width=12, fig.height=9, out.width="100%", fig.cap='(ref:rahlfFigCap)', fig.keep="last"}
<<rahlfplot>>
<<gridgraphics>>
<<downvp>>
<<multicol>>
<<rahlflatex>>
```

The details of the code that produces the main plot---everything except
the two columns of text in the top-left corner---are not relevant 
to this article so we perform this drawing
just with a call to a `rahlfPlot()` function that is defined in the
supplementary material for the article.  The result is shown in
Figure \@ref(fig:rahlfplain).

```{r eval=FALSE}
<<rahlfplot>>
```

(ref:rahlfplainFigCap) The main plot from Figure \@ref(fig:rahlf) without the two columns of text annotation.  This plot is drawn using functions from the `graphics` package.

```{r, rahlfplain, echo=FALSE, fig.width=12, fig.height=9, out.width="100%", fig.cap='(ref:rahlfplainFigCap)'}
<<rahlfplot>>
```

Because the main plot is drawn with the `graphics` package, 
in order to integrate the output from `grid.latex()` with the plot,
we need to convert it to an equivalent drawing that uses
functions from the `grid` package.
This can be achieved with the `grid.echo()` function from the
\CRANpkg{gridGraphics} package [@pkg-gridgraphics], as shown below.

```{r eval=FALSE}
<<gridgraphics>>
``` 

We want to align the LaTeX text with the main plot.  In particular, we want
the top of the text to be aligned with the value 14,000 on the y-scale
of the plot.  There is also a 1cm gap between the left of the text 
and the y-axis line.
In order to achieve this, we can navigate to the `grid` viewport
that corresponds to the main plot region, which also has scales 
that match the plot scales.

```{r eval=FALSE}
<<downvp>>
```

We are now ready to render the LaTeX text within the plot.
The LaTeX code for this example is shown below. 
This is a larger LaTeX fragment than we have previously seen,
but more importantly it contains a larger number of LaTeX commands 
to control the typesetting of the text.
For example, we control the font family with a `\setmainfont` command,
we control font size and vertical line spacing
with a `\fontsize` command, 
we control the overall width of the text using a `minipage`
environment, 
we set the number of columns using a `multicol` environment,
and we control the horizontal spacing between columns with
a `\setlength` command.

```{r echo=FALSE}
cat(rahlfTeX)
```

The `\setmainfont` and 
`\fontsize` commands in the LaTeX code require the LaTeX package `fontspec`
to be loaded, but this is not a problem because there is predefined support
for `fontspec` in the `xdvir` package.  However, the `multicol` environment
in the LaTeX code requires the LaTeX package `multicol` and there is no
predefined support for that in `xdvir`.  The following code uses the
`LaTeXpackage()` function to provide support for the LaTeX package `multicol`.
In a simple case like this, all we have to do is provide a name for the 
package (`"multicol"`) and use the `preamble` argument to
provide the LaTeX code that should be added in the
authoring step to load the LaTeX package.
We also call the `registerPackage()` function so that we can refer to this LaTeX
package by its name.

```{r eval=FALSE}
<<multicol>>
```

Finally, we call `grid.latex()` to add the LaTeX text to the plot.
The object `rahlfTeX` contains the LaTeX code,
we specify the LaTeX packages that have to be loaded, including
the `"multicol"` package that we just registered, and
we position the text 1cm in from the left of the
the plot viewport and at 14,000 on the y-axis.

```{r eval=FALSE}
<<rahlflatex>>
```

The final result is shown in Figure \@ref(fig:rahlf).

# Example 2

This section looks at another more complete example of a plot with
a LaTeX annotation (Figure \@ref(fig:schneider)).  This example
demonstrates the sophisticated effects that are possible by
combining TikZ graphics with LaTeX typesetting, in this case
to produce an annotated mathematical equation.

```{r echo=FALSE}
source("scripts/schneider.R")
```
```{r schneiderplot, echo=FALSE, eval=FALSE}
ggSchneider
```

```{r echo=FALSE}
schneiderLines <- readLines("TeX/schneider.tex")
schneiderTeX <- paste(schneiderLines, collapse="\n")
```

```{r annotateequations, echo=FALSE, eval=FALSE}
annotateEquations <-
    LaTeXpackage(name="annotate",
                 preamble="\\usepackage{TeX/annotate-equations}")
registerPackage(annotateEquations)
```

```{r tikznobbox, echo=FALSE, eval=FALSE}
tikzNoBBox <-
    tikzPackage(name="tikzNoBBox", bbox=FALSE)
registerPackage(tikzNoBBox)
```

```{r roboto, echo=FALSE, eval=FALSE}
roboto <-
    LaTeXpackage(name="roboto",
                 preamble="\\usepackage[sfdefault,condensed]{roboto}")
registerPackage(roboto)
```

```{r anneq, echo=FALSE, eval=FALSE}
library(gggrid)

annotation <- function(data, coords) {
    latexGrob(schneiderTeX, 
              packages=c("tikzNoBBox", "annotate", "roboto"),
              x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
              y=coords$y, hjust=1, vjust=1)
}

ggSchneider +
    grid_panel(annotation, 
               aes(x=x, y=y), 
               data=data.frame(x=160, y=dnorm(100, mean=100, sd=15)))
```

(ref:schneiderFigCap) A plot with annotated mathematical equation. This plot is an adaptation of the plot in @schneider2023.

```{r, schneider, echo=FALSE, fig.cap='(ref:schneiderFigCap)'}
<<annotateequations>>
<<tikznobbox>>
<<roboto>>
<<anneq>>
```

The main plot in this example is a \CRANpkg{ggplot2} plot.
The details of the code that generates the main plot
are not particularly relevant to this article, so the
main plot is described in the object `ggSchneider`, which
is defined in the supplementary materials for the article.
One point worth noting is that the labeling on the x-axis, which
combines italic Greek letters with upright digits and signs, is produced
using the \CRANpkg{ggtext} package.
In other words, this example combines two levels of text annotation:
labels on the x-axis that are relatively simple, but still beyond the
capabilities of core R text drawing;  and much more sophisticated 
text annotations that require access to a complex system like LaTeX.
The main plot produced by `ggSchneider` is shown in Figure 
\@ref(fig:schneiderplain).

```{r eval=FALSE}
ggSchneider
```

(ref:schneiderplainFigCap) The main plot from Figure \@ref(fig:schneider) without the annotated mathematical equation. This plot is produced using the packages \CRANpkg{ggplot2} and \CRANpkg{ggtext}.

```{r, schneiderplain, echo=FALSE, fig.cap='(ref:schneiderplainFigCap)'}
ggSchneider
```

The start of the LaTeX code for the annotated equation is shown below
(the full code is included in the supplementary materials for this article).
This is arranged in three blocks: the first block of code defines some colors;
the second block describes the main mathematical equation, but includes
some `\eqnmark` commands to save locations within the equation;
and the third block shows one of the additional equation annotations, which
refers to one of the saved locations within the main mathematical 
equation, in this case
the "z", and positions a
label relative to that location, in this case the label "z-score",
which is positioned
above and to the left of the "z".


```{r echo=FALSE}
ann2 <- grep("[\\]annotate", schneiderLines)[2]
cat(schneiderLines[1:(ann2 - 1)], sep="\n")
```

There are several LaTeX packages required by this LaTeX code,
in particular the `\eqnmark` and `\annotate` commands require the LaTeX 
package `annotate-equations`.
As in the previous example, we can add support for this package
using the `LaTeXpackage()` and `registerPackage()` functions.

```{r eval=FALSE}
<<annotateequations>>
```

The LaTeX package `annotate-equations` is built on TikZ graphics.
We do not need to load the LaTeX package `tikz` because `annotate-equations`
will do that automatically.  However, `xdvir` by default makes use 
of the bounding box information from TikZ graphics and, for images with
saved locations like this, that bounding box is unreliable.
The predefined support for the LaTeX package `tikz` in the `xdvir` package
includes a `tikzPackage()` function that allows us to load TikZ, but 
ignore its bounding boxes, as shown in the following code.

```{r eval=FALSE}
<<tikznobbox>>
```

Finally, we will use the LaTeX package `roboto` to access 
specific variations of the Roboto font for the text labels
in the annotated equation.

```{r eval=FALSE}
<<roboto>>
```

Rendering the annotated equation on the plot
requires integrating the LaTeX output with the
\CRANpkg{ggplot2} plot.  In particular, we want to align the top of the LaTeX
output with the top of the density curve and we want to align the right side
of the LaTeX output with the right edge of the label "160" on the x-axis.

We saw in an earlier section
how to use `element_latex()` to draw LaTeX text
in labels such as the plot title on a \CRANpkg{ggplot2} plot
and how to use `geom_latex()` to draw LaTeX text
as data symbols.
In this example, we are adding a single LaTeX annotation at a specific
position within a \CRANpkg{ggplot2} plot, so 
we use the \CRANpkg{gggrid} package [@pkg-gggrid].
This package provides the `grid_panel()` function, to which we pass a
function, in this case `annotation()`, plus mappings from data to 
aesthetics like for normal \CRANpkg{ggplot2} geoms. 
The `annotation()` function creates a `grid` grob for \CRANpkg{ggplot2} 
to draw, in this case using `latexGrob()`, which is similar to 
`grid.latex()` except that it creates a description of something to draw
rather than immediately drawing it.
We give the call to `latexGrob()` the LaTeX code to draw (`schneiderTeX`), 
a set of `packages` to load, and arguments that position
the output relative to the plot.

```{r eval=FALSE}
<<anneq>>
```

The final result is shown in Figure \@ref(fig:schneider).

# Example 3

This provides another demonstration of the range of possibilities from
LaTeX typesetting, by adding annotations that are formatted as numbered
list items, as shown in Figure \@ref(fig:anzjs).

```{r, echo=FALSE}
source("scripts/anzjs.R")
```

```{r anzjsplot, echo=FALSE, eval=FALSE}
ggANZJS
```

```{r echo=FALSE}
closeTeX <- r"(%
\fontsize{10}{12}
\selectfont
\begin{enumerate}
\item New Zealand closes its borders to {\it almost} all travellers at
{\bf 23:59, 19 March 2020 (NZDT)}.
\end{enumerate})"
```

```{r labelLeft, echo=FALSE, eval=FALSE}
labelLeft <- function(data, coords) {
    x1 <- coords$x[1]
    x2 <- coords$x[2]
    w <- unit(1 - x2, "npc") - unit(1, "mm")
    gap <- 15
    latex1 <- latexGrob(closeTeX,
                        x=unit(x1, "npc") - unit(2, "mm"), 
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
                        hjust=1, vjust=1,
                        width=w)
}
```

```{r labelRight, echo=FALSE, eval=FALSE}
labelRight <- function(data, coords) {
    x1 <- coords$x[1]
    x2 <- coords$x[2]
    w <- unit(1 - x2, "npc") - unit(1, "mm")
    gap <- 15
    latex1 <- latexGrob(closeTeX,
                        x=unit(x1, "npc") - unit(2, "mm"), 
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"),
                        hjust=1, vjust=1,
                        width=w)
    openTeX <- r"(%
\fontsize{10}{12}
\selectfont
\begin{enumerate}\addtocounter{enumi}{1}
\item New Zealand's international border opens to all visitors from
{\bf 11:59PM, 31 July 2022 (NZDT)}.
\end{enumerate})"
    latex2 <- latexGrob(openTeX,
                        x=unit(x2, "npc") + unit(2, "mm"),
                        y=unit(0, "npc") - unit(gap, "mm") - unit(2, "mm"), 
                        hjust=0, vjust=1,
                        width=w)
    latex2
}
```
```{r ggenumlist, echo=FALSE, eval=FALSE}
ggANZJS +
    grid_panel(labelLeft,
               aes(x=borders),
               data=data.frame(borders=c(borderClosed, borderOpen))) +
    grid_panel(labelRight,
               aes(x=borders),
               data=data.frame(borders=c(borderClosed, borderOpen)))
```

(ref:anzjsFigCap) A plot with numbered list items as annotations. This plot is an adaptation of Figure 10 from @anzjs2025.

```{r, anzjs, echo=FALSE, fig.width=8, fig.height=4.5, out.width="100%", fig.cap='(ref:anzjsFigCap)'}
<<labelLeft>>
<<labelRight>>
<<ggenumlist>>
```

The main plot is a \CRANpkg{ggplot2} plot with a number of relatively
simple annotations already added.
The details of the code are not particularly relevant to this
article, so the main plot is described in the object `ggANZJS`,
which is defined in the supplementary materials for the article.
One point worth noting is that the LaTeX annotations that we will
be adding are required to fit within the lines that extend below the plot.
In other words, we will be specifying a width for the LaTeX output
to fit into.
The main plot produced by `ggANZJS` is shown in Figure \@ref(fig:anzjsplain).

```{r eval=FALSE}
ggANZJS
```

(ref:anzjsplainFigCap) The main plot from Figure \@ref(fig:anzjs) without the numbered list items as annotations.  This plot is produced using the \CRANpkg{ggplot2} package.

```{r, anzjsplain, echo=FALSE, fig.width=8, fig.height=4.5, out.width="100%", fig.cap='(ref:anzjsplainFigCap)'}
ggANZJS
```

We will focus on drawing just the left-hand LaTeX annotation.
The LaTeX code is shown below.
This includes commands to control the font size and an `enumerate`
environment that creates a numbered list item.

```{r echo=FALSE}
cat(closeTeX)
```

As with the previous example, we have a single annotation that we want
to position quite carefully, so we define a function that generates 
a `grid` grob to use with the `grid_panel()` function from the 
\CRANpkg{gggrid} package.
The `labelLeft()` function calls `latexGrob()`, gives it the LaTeX code
to draw (`closeTeX`), specifies the position for the LaTeX output,
and specifies a `width` for the output to be typeset within.

```{r eval=FALSE}
<<labelLeft>>
```

The following code combines the left-hand label annotation,
and a very similar right-hand label annotation, with the
`ggANZJS` plot.

```{r eval=FALSE}
<<ggenumlist>>
```

The final result is shown in Figure \@ref(fig:anzjs).

# Example 4

**TODO**
Go back to panel function for lattice example.
Bundle main plot panel into its own 
function so that panel function is still simple.
Also point out that a lattice label (like title and xlab/ylab) can be any grob.
Can we do example that shows both of these ?

This section provides an example, shown in
Figure \@ref(fig:latticemd), of using other software to generate
LaTeX code, rather than writing it directly.
It also demonstrates integrating `grid.latex()` output
with a \CRANpkg{lattice} plot [@pkg-lattice].

```{r echo=FALSE}
library(lattice)
library(latticeExtra)
```

```{r yaml, echo=FALSE}
yaml <- "
---
mainfont: TeX Gyre Heros
header-includes:
- \\pagestyle{empty}
- \\usepackage{geometry}
- \\geometry{textwidth=1.8in}
---
"
```

```{r mdleft, echo=FALSE}
mdLeft <- "
1. New Zealand closes its borders to *almost* all travellers
   at **23:59, 19 March 2020 (NZDT)**.
"
```

```{r mdright, echo=FALSE}
mdRight <- "
2. New Zealand's international border opens to all visitors
   from **11:59PM, 31 July 2022**.
"
```

```{r pandocleft, echo=FALSE}
oldwd <- setwd("Markdown")
writeLines(c(yaml, mdLeft), "labelLeft.md")
rmarkdown::pandoc_convert("labelLeft.md", 
                          output="labelLeft.tex",
                          options="--standalone")
latexLeft <- readLines("labelLeft.tex")
setwd(oldwd)
```

```{r pandocright, echo=FALSE}
oldwd <- setwd("Markdown")
writeLines(c(yaml, mdRight), "labelRight.md")
rmarkdown::pandoc_convert("labelRight.md", 
                          output="labelRight.tex",
                          options="--standalone")
latexRight <- readLines("labelRight.tex")
setwd(oldwd)
```

```{r typesetleft, echo=FALSE}
dviLeft <- typeset(latexLeft)
```

```{r typesetright, echo=FALSE}
dviRight <- typeset(latexRight)
```

```{r lattice, echo=FALSE}
latticeFlights <- 
    xyplot(total ~ date, flights, type="l", 
           main=list(label="Total flights into and out of Auckland",
                     x=0, hjust=0),
           xlab="", ylab=NULL,
           ylim=c(0, 1800000), family="Lato Light", 
           scales=list(y=list(at=c(0, 500000, 1000000),
                              labels=c("0", "500,000", "1,000,000"))),
           panel=function(...) {
                     panel.xyplot(...)
                     panel.abline(v=c(borderClosed, borderOpen), lty="dashed")
                 })
```

```{r latticeflights, echo=FALSE, eval=FALSE}
latticeFlights + 
    latticeExtra::layer(render(dviLeft, 
                               x=unit(borderClosed, "native") - unit(2, "mm"),
                               y=unit(1, "npc") - unit(2, "mm"),
                               hjust="right", vjust="top"))
```

```{r latticefinal, echo=FALSE}
temp <- 
<<latticeflights>>
latticeFinal <- temp + 
    latticeExtra::layer(grid.dvi(dviRight, 
                   x=unit(borderOpen, "native") + unit(2, "mm"),
                   y=unit(1, "npc") - unit(2, "mm"),
                   hjust="left", vjust="top"))
```

(ref:latticemdFigCap) A plot with numbered list items as annotations. The list items in this plot are specified using Markdown rather than LaTeX.

```{r, latticemd, echo=FALSE, fig.width=8, out.width="100%", fig.cap='(ref:latticemdFigCap)'}
latticeFinal
```

The main plot is a \CRANpkg{lattice} plot, with some annotations
already in place.  The details of the code for this plot are not
relevant to this article, so the main plot is described in the object
`latticeFlights`, which is defined in the supplementary material.
The main plot produced by `latticeFlights` is shown in 
Figure \@ref(fig:latticemdplain).
 
```{r eval=FALSE}
latticeFlights
```

(ref:latticemdplainFigCap) The main plot from Figure \@ref(fig:latticemd).  This plot is produced using the \CRANpkg{lattice} package.

```{r, latticemdplain, echo=FALSE, fig.width=8, out.width="100%", fig.cap='(ref:latticemdFigCap)'}
latticeFlights
```

The annotations in Figure \@ref(fig:latticemd) are enumerated list items,
similar to those in Figure \@ref(fig:anzjs).  However, in this plot
instead of writing explicit LaTeX code, we use
Markdown syntax to 
describe the list item, as shown below.
We will just focus on the left annotation;
the right annotation is added in a very similar fashion.

```{r echo=FALSE}
cat(mdLeft)
```

We can
use `pandoc_convert()` from the \CRANpkg{rmarkdown} package [@pkg:rmarkdown]
to convert the Markdown to LaTeX code, as shown below.
Because we want the enumerated list to be constrained to a narrow width
and because we want the font to match the main plot font, we
have to add a YAML header to the markdown.

```{r echo=FALSE}
cat(yaml)
```

The following code combines the YAML header with the Markdown code,
writes the result to a file, converts the Markdown to LaTeX, and
reads the resulting LaTeX back into R.

```{r eval=FALSE}
<<pandocleft>>
```

These extra steps
somewhat undermine the relative simplicity of using Markdown code,
but the example still demonstrates the general idea of 
generating LaTeX code from other sources rather than writing
it explicitly ourselves.

We now have LaTeX code to render in R, but a further complication
is that this is a complete 
LaTeX document rather than just a LaTeX fragment.
We cannot pass a complete document to `grid.latex()`;
instead, 
we pass the LaTeX document to `typeset()` to generate
a `"DVI"` object (see Figure \@ref(fig:diag)).

```{r eval=FALSE}
<<typesetleft>>
```

The following code demonstrates that we can render
this `"DVI"` object within the \CRANpkg{lattice} plot
using the `layer()` function from the 
\CRANpkg{latticeExtra} package [@pkg:latticeExtra].
The first argument to that function is code that produces
output to add to the \CRANpkg{lattice} plot.
We provide a call to the `render()` function
from the `xdvir` package to draw the output described in `dviLeft`.
Similar code is used to generate and add the second list item.

```{r eval=FALSE}
<<latticeflights>>
```

The final result is shown in Figure \@ref(fig:latticemd).

# Discussion

The `xdvir` package provides convenient high-level functions for 
rendering LaTeX fragments as labels, annotations, or data symbols on
R plots.  The package also provides lower-level functions that
allow more fine control over the authoring, typesetting, and
rendering of LaTeX code in R.

The benefit of the `xdvir` package is access to the typesetting capabilities
of LaTeX.  This ranges from relatively simple features like changes in
font family, font weight, and font style, and automatic line breaks,
to intermediate features like full justification, hyphenation, and high-quality
mathematical formulas and equations, and more advanced features like
enumerated lists, multiple columns, and TikZ graphics.

One limitation of the `xdvir` package is that rendering LaTeX
fragments is noticeably slower than rendering simple character values.
This is mainly because the typesetting 
step requires running a TeX engine to produce a DVI file.
The `xdvir` package performs some caching in order to minimize the problem,
but the time cost can still be quite large.

Another limitation of the `xdvir` package is that it requires a
graphics device that can render typeset glyphs.  This currently includes
the `pdf()` and `quartz()` devices, plus all devices based on the 
Cairo graphics library [@cairo], and graphics devices 
provided by the `ragg` package [@pkg:ragg].

A final major limitation of `xdvir` is that it only currently supports two
TeX engines:  XeTeX and recent LuaTeX.  The package start-up message 
reports on whether these are available.  An implicit limitation is that
`xdvir` requires a TeX installation, though that is simplified 
through a dependency on the \CRANpkg{tinytex} package [@pkg:tinytex].

Given these limitations, it is worth discussing alternative approaches.
The first section of this article mentioned \CRANpkg{gridtext},
\CRANpkg{ggtext}, and \CRANpkg{marquee}.  These packages
provide alternative ways to render non-trivial text labels, but 
do so through Markdown and/or HTML rather than LaTeX.
There are, in addition, a number of packages that perform specific
text-placement tasks, for example \CRANpkg{geomtextpath} [@pkg:geomtextpath],
which can arrange text along an arbitrary path, and
\CRANpkg{directlabels} [@pkg:directlabels] and 
\CRANpkg{ggforce} [@pkg:ggforce], which provide functions for adding
text annotations.
The advantage of `xdvir` by comparison with these packages
is that it is possible to
produce more advanced typesetting results thanks to having access to LaTeX.

The \CRANpkg{tikzDevice} package [@pkg:tikzDevice] is an interesting
alternative because, where `xdvir` integrates LaTeX text with R graphics, 
\CRANpkg{tikzDevice} reverses the process and integrates R graphics with LaTeX.
The \CRANpkg{tikzDevice} package provides an R graphics device that
converts R plots into TikZ pictures so that R plots can include labels with 
LaTeX fragments and R plots can be 
deeply integrated with LaTeX documents.
The main difference with this package is the destination:
if we use `xdvir`, we end up with LaTeX output within an R plot;
if we use \CRANpkg{tikzDevice} we end up with an R plot within LaTeX output.
If the final destination is a LaTeX document, 
then the \CRANpkg{tikzDevice} may provide more convenience
and greater control. However, if the final destination is 
more general, or unknown, then `xdvir` may be the more appropriate
solution.

The \CRANpkg{latex2exp} package [@pkg:latex2exp] is another package
that works in the opposite direction to `xdvir`.  This package
takes a LaTeX fragment and converts it to an R "plotmath" expression.
This allows users familiar with LaTeX to access R's math-drawing facility
whereas `xdvir` allows users to access LaTeX's math-drawing facility,
which is far superior.  The advantage of \CRANpkg{latex2exp}, as with
many of these alternative approaches, is that it does not have any
system dependencies, whereas `xdvir` requires a TeX installation.

Another alternative approach to including LaTeX output in R plots
is to import an image of the LaTeX output.
This approach harks back to early solutions for including 
LaTeX mathematical expressions in web pages by generating PNG images
from LaTeX fragments.
However, more modern technologies, such as SVG mean that this
approach can yield a much higher-quality result, as 
demonstrated by @schneider2023.
One simple advantage of the `xdvir` approach is the level of convenience
that it provides by automating the authoring and typesetting steps.
The `xdvir` package also provides more possibilities to integrate
LaTeX output with other drawing in R through anchors and saved positions.

Some of the limitations of `xdvir` may also be overcome by further 
development.  For example, it may be possible to extend support
to more TeX engines and to more graphics devices.  Providing support
for more LaTeX packages is another area for
future work.

# Acknowledgments

The `xdvir` package depends on Yihui Xie's \CRANpkg{tinytex} package
for the typesetting step.  This package makes it much
simpler to make use of TeX engines, 
including performing multiple runs when necessary, and much easier
to install
LaTeX packages (and TeX itself).

Claus O. Wilke's \CRANpkg{ggtext} package and Thomas Lin Pedersen's
\CRANpkg{marquee} package provided excellent templates for the integration
of improved text-drawing facilities with \CRANpkg{ggplot2}.

The author owes a debt of gratitude to Marc-Olivier Beausoleil 
(Figure \@ref(fig:typesetting)), 
Thomas Rahlf (Figure \@ref(fig:rahlf)), 
and Joel Schneider (Figure \@ref(fig:schneider))
for sharing their work and for
for permission to base several of the examples in this article
on their work.


