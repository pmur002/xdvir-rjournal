---
title: "Rendering LaTeX in R"
date: "2024-12-31"
abstract: >
  An abstract of less than 150 words.
draft: true
author:  
  - name: Paul Murrell
    affiliation: The University of Auckland
    address:
    - Department of Statistics
    - Auckland, New Zealand
    email: paul@stat.auckland.ac.nz
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
type: package
output: 
  rjtools::rjournal_web_article:
    self_contained: yes
    toc: no
bibliography: murrell-xdvir.bib

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

# Introduction

Text labels, titles, and annotations are essential components of 
any data visualisation.  Viewers focus a lot of their attention
on text [@massvis], 
text is the most effective way to communicate some types of 
information [@hearst],
and the message obtained from a data visualisation can be
heavily influenced by text [@kong].

R provides relatively flexible tools for adding text labels to plots.
For example, in the `graphics` package, we can specify an
overall title and axis titles via the `main`,
`xlab`, and `ylab` arguments to the `plot()` function
and we can add text at arbitrary locations on the plot with the `text()` 
and `mtext()` functions.

Unfortunately, these core tools for drawing text are quite limited
in terms of the formatting of the text.
For example, there is no facility for emphasising an individual word using
a **bold** or *italic* face within a text label.

The \CRANpkg{gridtext} [@pkg-gridtext] and \CRANpkg{ggtext} [@pkg-ggtext]
packages greatly improved the situation by allowing text labels
to include a small subset of
markdown and HTML (plus CSS).  This allowed changes in font face
and colour within text labels.

More recently, the \CRANpkg{marquee} package [@pkg-marquee]
improved things a great deal further by providing full support for
markdown within text labels.  This made it possible to layout more
complex arrangements of text and graphical content within "text" labels.

However, despite these advances, there are still some text formatting tasks that
remain out of reach.  For example, Figure \@ref(fig:typesetting) 
shows a plot with a text annotation in the top-right corner containing
a combination of features that cannot be produced using the 
available text-drawing tools.

```{r echo=FALSE}
## Parameter for plotting
## Set x variable for the fitness function 
x <- seq(-1, 7.5, by = .01)

## Math parameters for Fitness function 
s <- .5
m <- 1.5
t <- 1.7
u <- 3.4
div1 <- 2.4
div2 <- 3.5

## Set population parameters
## NB individuals, try with 10, and 1000 
n <- 1000 
## Get fake phenotypes
## Phenotypes for the population
pheno <- rnorm(n = n, mean = 3.2, sd = 0.5) 
## Make y height just for vizualisation purpose 
fit <- rnorm(length(pheno), mean = .12, sd =.01)


## Load functions ----------------------------------------------------------
## Mathematical fitness function (2 peaks )
## This is a speculative fitness function, you could design your own.
fit.function  <- function(x, s, m, t, u, div1 = 2, div2 = 2.5) {
    exp(-s^(-2)*(x-m)^(2))/div1+exp(-t^(-2)*(x-u)^(2))/div2
}

y <- fit.function(x = x,s = s, m = m,t = t,u = u, div1 = div1, div2 = div2)

main.plot <- function(mar = c(3, 3, .25, .25), col = 2) {
    ## Set parameter of plotting area 
    par(mar = mar)
    ## Plot fitness function 
    plot(y ~ x, 
         xlim = c(-0.5, 7),
         ylim = c(0, .7),
         axes=FALSE,
         type = "l", lwd = 5, col = col, 
         ylab = "Fitness", xlab = "Phenotypes")
    axis(1)
    axis(2, at=seq(0, .6, .2))
    box()
}

dens.xy <- density(x = pheno, n = 512, adjust = 2) # Adjust to make it smoother 

## Make a fake population 
add.fake.pop <-  function(x = dens.xy, y = fit,  alp = 1) {
    ## Line at the mean 
    ## abline(v = mean(x), lty = 3)
    ## Calculate the density of the population 
    ## Add density 
    lines(x = dens.xy$x, y = dens.xy$y/3, lty = 2)
}

drawPlot <- function() {
    par(family="TeX Gyre Adventor", mgp=c(2, .7, 0))
    main.plot()
    add.fake.pop(alp = .1)
}
```

```{r, echo=FALSE}
texStr <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3.3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the \textcolor{Rred}{fitness function}.
\end{minipage})"
```

```{r, typesetting, echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=4.5, dpi=300, fig.keep="last", fig.cap="A plot with a text annotation that contains several typesetting challenges:  in-line mathematical equations; changes in colour; and automated line-breaks with full justification and hyphenation. Thanks to Marc-Olivier Beausoleil for permission to reproduce this data visualisation."}

library(xdvir)
adventor <- fontspecPackage(font="TeX Gyre Adventor", name="adventor")

library(gggrid)

gg <- ggplot(data.frame(x, y)) +
    geom_line(aes(x, y), linewidth=2, colour=2) +
    geom_line(aes(x, y), data=data.frame(x=dens.xy$x, y=dens.xy$y/3),
              linetype="dashed") +
    xlab("Phenotypes") +
    ylab("Fitness") +
    theme_bw() +
    theme(text=element_text(family="TeX Gyre Adventor", size=12),
          panel.grid=element_blank())

gg + 
    grid_panel(latexGrob(texStr, packages=list(adventor, "xcolor"),
               x=unit(1, "npc") - unit(5, "mm"), 
               y=unit(1, "npc") - unit(5, "mm"),
               hjust="right", vjust="top"))

notrun <- function() {

drawPlot()

library(gridGraphics)
grid.echo()
downViewport("graphics-window-1-1")

tex <- author(texStr, packages=list(adventor, "xcolor"))
dviFile <- typeset(tex)
dvi <- readDVI(dviFile)
grid.dvi(dvi,
         x=unit(1, "npc") - unit(5, "mm"), y=unit(1, "npc") - unit(5, "mm"),
         hjust="right", vjust="top")

}
```

The annotation in Figure \@ref(fig:typesetting)
may not appear to be particularly special nor particularly complicated 
at first glance, but it harbours several important details:

* The text is a mixture of plain text and mathematical expressions (like
  $\bar{z}_i$). Furthermore, the mathematical expressions use a different font
  (Latin Modern) than the plain text (TeX Gyre Adventor).

  The R graphics system can draw mathematical expressions [@plotmath]
  and that includes a mixture of plain text and mathematical expressions,
  but it can only use the same font for the entire mixture.
  There is also the problem
  that the typesetting of mathematical expressions in R graphics is not
  particularly pretty.

* The text is not all the same colour; the final two words (but not the full
  stop) are red.

  The R graphics system can only draw a character value with a single colour.
  The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages make it possible to change colour within
  a character value, but they do not allow a mixture of plain text and
  mathematical expressions.

* The text is broken over multiple lines. Furthermore, the text is fully
  justified (not ragged-left or ragged-right justified) and two of the words
  have been split across lines and hyphenated. Although it is not
  obvious from the plot itself, the line breaks were also automatically
  generated to fit the text into a fixed width (3.3 inches).

  The R graphics system can draw a character value across multiple lines, but
  only if explicit newlines are embedded in the character value (i.e., the line
  breaks are manual). The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages can calculate simple
  automated line breaks, but they will not break a word across lines (or
  hyphenate) and they cannot fully justify the resulting text. The
  \CRANpkg{marquee} package can automate line breaks and fully justify
  text, but it cannot hyphenate nor can it produce mathematical equations.

The features outlined above are all examples of *typesetting*; determining an
arrangement of individual characters and symbols (glyphs) that could be as
simple as placing one character after another (from left to right), but could
also be as complex as arranging mathematical symbols, splitting text into
multiple columns, or writing text vertically from top to bottom.

From R 4.3.0, it has been
possible to draw text from a set of typeset glyphs using the
functions `grDevices::glyphInfo()` and `grid::grid.glyph()`
[@murrell-pedersen-urbanek-glyphs-2023]. However, that
facility presupposes that we are able to generate a set of typeset glyphs.

The \CRANpkg{marquee} package provides an example of a package
that can generate typeset glyphs.  It is capable of converting
markdown input into a set of glyphs and their positions, which are
then rendered in R.

This article describes the `xdvir` package, which is another example
of a package that can generate typeset glyphs.
In this case, the input is LaTeX, a TeX engine is used to
generate a set of glyphs and their positions, and then the
result is rendered in R.
The benefit of the `xdvir` package is that it provides access to the
typesetting capabilities of LaTeX, which includes hyphenation,
fully justified text, mixtures of plain text and mathematical equations---all
of the features demonstrated in Figure \@ref(fig:typesetting) and much more.

The next section describes the basic usage of the `xdvir` package.
This is followed by a section that breaks down the 
design of the `xdvir` package to show the steps that are
required to render LaTeX output in R.
Subsequent sections present a series of examples that demonstrate
a range of different features and applications of the
`xdvir` package.

# LaTeX text labels

The simplest way to draw LaTeX text with the `xdvir` package 
is to call the `grid.latex()` function.  The first argument to
this function is a character value, which is interpreted as
a fragment of LaTeX code.
For example, the following code draws a text label that contains
a fragment of the larger annotation from 
Figure \@ref{fig:typesetting}.  We use just a fragment in order
to keep the code readable.

Because LaTeX code tends to contain 
a large number of backslashes, the code below uses the `r"(...)"`
syntax for raw character constants, so that we do not have to
escape each backslash with a double backslash.
The resulting image is shown below the code.
Although it is not immediately obvious from that image, 
the text, or rather the glyphs, in the image are rendered by R.

```{r, fragment}
tex <- r"(We move the original mean to $\bar z_i$)"
```

```{r grid.latex, fig.width=3, fig.height=.5}
grid.latex(tex)
```

As the function name `grid.latex()` suggests, the code above
is producing low-level 
drawing in the `grid` package graphics system.
The text is just drawn relative to the current `grid` viewport,
wherever that may be on the page.
While this is extremely flexible, it is more likely that 
we want to combine and coordinate the text with a high-level plot
of some sort.
There are various ways that low-level `grid` drawing can be combined
with a high-level plot, but we will leave those demonstrations to
later sections.

Instead, for now, we will demonstrate a more common scenario:
drawing LaTeX text labels on a \CRANpkg{ggplot2} plot [@pkg-ggplot2].
For this purpose, the `xdvir` package provides the
`element_latex()` function.  This allows us to specify a LaTeX fragment
as a plot label and indicate the special nature of the label
via the `ggplot2::theme()` function.

For example, the following code uses the same LaTeX fragment 
from the example above as the title of a \CRANpkg{ggplot2} plot.
The resulting plot is shown in Figure \@ref(fig:element.latex).

The `gg` object in the code below
contains a description of the main \CRANpkg{ggplot2} 
plot from Figure 
\@ref(fig:typesetting).  The supplementary materials for this article
includes full code for generating that `gg` object.

```{r, element.latex, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=4.5, dpi=300, fig.cap="A `ggplot2` plot with a title that was specified using a LaTeX fragment."}
gg +
    labs(title=tex) +
    theme(plot.title=element_latex())
```

The `xdvir` package also provides a `geom_latex()` function for
drawing text labels based on data, but that will be demonstrated 
in later sections.

# Under the Hood

The previous section showed that simple usage of the `xdvir` package
only requires specifying a LaTeX fragment as the text to draw.
For example, the examples used the LaTeX fragment shown below.

```{r}
tex
```

The `grid.latex()` function has three tasks to perform in order to
draw that LaTeX fragment in R:

**Authoring:**

: The LaTeX fragment has to be turned into a complete
  LaTeX document.

: The `xdvir` package provides the function `author()` for this purpose.
  For example, the following code
  takes the LaTeX fragment `tex` and produces a complete LaTeX
  document that is ready to typeset.

```{r}
doc <- author(tex)
doc
```

**Typesetting:**

: The LaTeX document has to be typeset to produce a set of 
  glyphs and their positions.

: The `xdvir` package provides the function `typeset()` for this purpose.
  For example, the following code takes the LaTeX document `doc` and
  produces a `"DVI"` object that contains instructions on the fonts to
  use (lines that contain `x_fnt_def` and `fnt_num` in the output below), 
  the glyphs to use from those fonts (lines that contain
  `x_glyph` in the output below), and where to draw those glyphs
  (lines that contain `down` and `right` and `x_glyph`).

```{r}
dvi <- typeset(doc)
dvi
```  

**Rendering:**

: The result of the typesetting step has to be turned into drawing in R.

: The `xdvir` package provides the `grid.dvi()` function for this purpose.
  For example, the code below renders the typesetting information in `dvi`
  in R.

```{r fig.width=3, fig.height=.5}
grid.dvi(dvi)
```


# Fancy annotated equation example [@schneider2023]

+ NOTE that this nicely uses {ggtext} for simpler annotations, but
  has to go to LaTeX for fancy stuff
  => exactly the justification for {xdvir}

+ NOTE this is also an example of writing new LaTeXpackage()

```{r echo=FALSE}
library(ggtext)
library(signs)
```

```{r echo=FALSE}
## Set up "data"
mu <- 100
sigma <- 15
plot_height <- dnorm(mu, mu, sigma)
lb <- -4 * sigma + mu
ub <- 4 * sigma + mu
```

```{r echo=FALSE}
## Set up main plot
## NOTE need some data for grid_panel() to be called at all
gg <- ggplot(data.frame(x=160, y=dnorm(mu, mean=mu, sd=sigma))) +
    stat_function(fun=function(x) dnorm(x, mean=mu, sd=sigma),
                  geom="area",
                  n=1000,
                  fill="dodgerblue",
                  alpha=.5) +
    theme_classic(base_family="Roboto Condensed",
                  base_size=18) +
    theme(axis.text.x=element_markdown(),
          axis.title.x=element_markdown(),
          axis.line=element_blank())  +
    scale_x_continuous("Observed Score *X*<br>*z*",
                       breaks=seq(lb, ub, sigma),
                       limits=c(lb, ub),
                       labels=function(x)
                           paste0(signs(x),
                                  "<br>",
                                  ifelse(x == mu,
                                         "<em>&mu;</em>",
                                         paste0(signs((x - mu) / sigma,
                                                      add_plusses=T,
                                                      label_at_zero="none"),
                                                "<em>&sigma;</em>")))) +
    scale_y_continuous(NULL,
                       limits=c(0, plot_height),
                       expand=expansion(),
                       breaks=NULL) 
```

```{r echo=FALSE}
## Add {xdvir} annotation
library(xdvir)
library(gggrid)

annotateEquations <-
    LaTeXpackage(name="annotate",
                 preamble="\\usepackage{annotate-equations/annotate-equations}")
registerPackage(annotateEquations)
roboto <-
    LaTeXpackage(name="roboto",
                 preamble="\\usepackage[sfdefault,condensed]{roboto}")
registerPackage(roboto)
tikzNoBBox <-
    tikzPackage(name="tikzNoBBox", bbox=FALSE)
registerPackage(tikzNoBBox)

pkgs <- c("xcolor", "tikzNoBBox", "annotate", "roboto")

tex <- author(readLines("TeX/schneider.tex"), packages=pkgs)
dvi <- typeset(tex, texFile="TeX/schneider-doc.tex")

annotation <- function(data, coords) {
    dviGrob(dvi, packages=pkgs,
            x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
            y=coords$y, hjust=1, vjust=1)
}

gg +
    grid_panel(annotation, aes(x=x, y=y))
```

# ggplot2 example (geom and element)

```{r}
samples <- data.frame(x=rnorm(50), sample=rep(1:5, each=10))
means <- aggregate(samples$x, list(sample=samples$sample), mean)
means$label <- paste0("$\\bar x_", means$sample, "$")
xlabel <- r"(\begin{tikzpicture}\node[draw,circle,thick,inner sep=0.5mm]{\vphantom{M}$\mu$};\end{tikzpicture})"
```

```{r, message=FALSE}
ggplot(samples) +
    geom_vline(xintercept=0, linetype="solid", colour=1, linewidth=.5) +
    geom_point(aes(x, sample), colour="grey", size=4, alpha=.5) +
    geom_point(aes(x, sample), data=means, colour=2, size=4) +
    geom_latex(aes(x, sample, label=label), data=means, 
               size=6, vjust=-.4, colour=2) +
    xlab(NULL) +
    scale_x_continuous(breaks=0, labels=xlabel) +
    scale_y_continuous(breaks=1:5, expand=expansion(.25)) +
    theme_minimal() +
    theme(axis.text.x=element_latex(size=16, packages="tikz", 
                                    margin=margin(-3, 0, 0, 0)),
          axis.ticks.x=element_blank(),
          axis.title.y=element_text(colour="grey"),
          axis.text.y=element_text(colour="grey"),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.x=element_blank(),
          panel.grid.minor.y=element_blank())
```

# Use dvir-lualatex-float example 

Text typeset within irregular shape.
Example of more work happening in LaTeX code.
Example of grid.dvi() just dumped on top of other drawing
=> motivation for better alignment examples.

```{r echo=FALSE}
tex <- author(readLines("TeX/longley.tex"), packages="fontspec")
dvi <- typeset(tex, texFile="TeX/longley-doc.tex")
par(mar=c(4, 4, 1, 1))
barplot(GNP ~ Year, data = longley)
grid.dvi(dvi,
         x=unit(2.5, "cm"),
         y=unit(1, "npc") - unit(1, "cm"),
         hjust="left", vjust="top")
```

# RTL or Vertical layout example?

# Alignment

Do tikz example that draws arrow to location on plot?
(like dvir-tikz test)

Do example that draws grid arrow to location in tikz picture?
(needs implementing)

# gggrid

Need a \CRANpkg{gggrid} package 
[@pkg-gggrid] example.

# Acknowledgements

Must acknowledge tikzDevice package !!!

Owe big debt to the \CRANpkg{tinytex} package,
which simplifies the calling of TeX engines, installation
of TeX packages (and TeX itself),
and running TeX multiple times when necessary (e.g., for TikZ
position tracking).

# Summary

