---
title: "Rendering LaTeX in R"
date: "2024-12-31"
abstract: >
  An abstract of less than 150 words.
draft: true
author:  
  - name: Paul Murrell
    affiliation: The University of Auckland
    address:
    - Department of Statistics
    - Auckland, New Zealand
    email: paul@stat.auckland.ac.nz
    url: https://www.stat.auckland.ac.nz/~paul/
    orcid: 0000-0002-3224-8858
type: package
output: 
  rjtools::rjournal_web_article:
    self_contained: yes
    toc: no
bibliography: murrell-xdvir.bib

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
options(xdvir.engine="xetex")
```

# Introduction

Text labels, titles, and annotations are essential components of 
any data visualisation.  Viewers focus a lot of their attention
on text [@massvis], 
text is the most effective way to communicate some types of 
information [@hearst],
and the message obtained from a data visualisation can be
heavily influenced by text [@kong].

R provides relatively flexible tools for adding text labels to plots.
For example, in the `graphics` package, we can specify an
overall title and axis titles via the `main`,
`xlab`, and `ylab` arguments to the `plot()` function
and we can add text at arbitrary locations on the plot with the `text()` 
and `mtext()` functions.

Unfortunately, these core tools for drawing text are quite limited
in terms of the formatting of the text.
For example, there is no facility for emphasising an individual word using
a **bold** or *italic* face within a text label.

The \CRANpkg{gridtext} [@pkg-gridtext] and \CRANpkg{ggtext} [@pkg-ggtext]
packages greatly improved the situation by allowing text labels
to include a small subset of
markdown and HTML (plus CSS).  This allowed changes in font face
and colour within text labels.

More recently, the \CRANpkg{marquee} package [@pkg-marquee]
improved things a great deal further by providing full support for
markdown within text labels.  This made it possible to layout more
complex arrangements of text and graphical content within "text" labels.

However, despite these advances, there are still some text formatting tasks that
remain out of reach.  For example, Figure \@ref(fig:typesetting) 
shows a plot with a text annotation in the top-right corner containing
a combination of features that cannot be produced using the 
available text-drawing tools.

```{r echo=FALSE}
## Parameter for plotting
## Set x variable for the fitness function 
x <- seq(-1, 7.5, by = .01)

## Math parameters for Fitness function 
s <- .5
m <- 1.5
t <- 1.7
u <- 3.4
div1 <- 2.4
div2 <- 3.5

## Set population parameters
## NB individuals, try with 10, and 1000 
n <- 1000 
## Get fake phenotypes
## Phenotypes for the population
pheno <- rnorm(n = n, mean = 3.2, sd = 0.5) 
## Make y height just for vizualisation purpose 
fit <- rnorm(length(pheno), mean = .12, sd =.01)


## Load functions ----------------------------------------------------------
## Mathematical fitness function (2 peaks )
## This is a speculative fitness function, you could design your own.
fit.function  <- function(x, s, m, t, u, div1 = 2, div2 = 2.5) {
    exp(-s^(-2)*(x-m)^(2))/div1+exp(-t^(-2)*(x-u)^(2))/div2
}

y <- fit.function(x = x,s = s, m = m,t = t,u = u, div1 = div1, div2 = div2)

main.plot <- function(mar = c(3, 3, .25, .25), col = 2) {
    ## Set parameter of plotting area 
    par(mar = mar)
    ## Plot fitness function 
    plot(y ~ x, 
         xlim = c(-0.5, 7),
         ylim = c(0, .7),
         axes=FALSE,
         type = "l", lwd = 5, col = col, 
         ylab = "Fitness", xlab = "Phenotypes")
    axis(1)
    axis(2, at=seq(0, .6, .2))
    box()
}

dens.xy <- density(x = pheno, n = 512, adjust = 2) # Adjust to make it smoother 

## Make a fake population 
add.fake.pop <-  function(x = dens.xy, y = fit,  alp = 1) {
    ## Line at the mean 
    ## abline(v = mean(x), lty = 3)
    ## Calculate the density of the population 
    ## Add density 
    lines(x = dens.xy$x, y = dens.xy$y/3, lty = 2)
}

drawPlot <- function() {
    par(family="TeX Gyre Adventor", mgp=c(2, .7, 0))
    main.plot()
    add.fake.pop(alp = .1)
}
```

```{r, echo=FALSE}
texStr <- r"(\definecolor{Rred}{RGB}{223,83,107}
\begin{minipage}{3in}
We `move' the original population's mean to a new $\bar z_i$ 
and calculate the average fitness at that new mean phenotype 
of the population to get the adaptive landscape, $\bar W_i$, 
then we combine the population mean and the average fitness 
to get the \textcolor{Rred}{\bf fitness function}.
\end{minipage})"
```

```{r, typesetting, echo=FALSE, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=4.5, dpi=300, fig.keep="last", fig.cap="A plot with a text annotation that contains several typesetting challenges:  in-line mathematical equations; changes in colour; and automated line-breaks with full justification and hyphenation. Thanks to Marc-Olivier Beausoleil for permission to reproduce this data visualisation."}

library(xdvir)
adventor <- fontspecPackage(font="TeX Gyre Adventor", name="adventor")

library(gggrid)

ggIntro <- ggplot(data.frame(x, y)) +
    geom_line(aes(x, y), linewidth=2, colour=2) +
    geom_line(aes(x, y), data=data.frame(x=dens.xy$x, y=dens.xy$y/3),
              linetype="dashed") +
    xlab("Phenotypes") +
    ylab("Fitness") +
    theme_bw() +
    theme(text=element_text(family="TeX Gyre Adventor", size=12),
          panel.grid=element_blank())

annotation <- function(data, coords) {
    latexGrob(texStr, packages=list(adventor, "xcolor"),
              x=max(coords$x), 
              y=max(coords$y),
              hjust="right", vjust="top", 
              gp=NULL,
              texFile="typesetting.tex")
}

ggIntro + 
    grid_panel(annotation, aes(x, y))
```

The annotation in Figure \@ref(fig:typesetting)
may not appear to be particularly special nor particularly complicated 
at first glance, but it harbours several important details:

* The text is a mixture of plain text and mathematical expressions (like
  $\bar{z}_i$). Furthermore, the mathematical expressions use a different font
  (Latin Modern) than the plain text (TeX Gyre Adventor).

  The R graphics system can draw mathematical expressions [@plotmath]
  and that includes a mixture of plain text and mathematical expressions,
  but it can only use the same font for the entire mixture.
  There is also the problem
  that the typesetting of mathematical expressions in R graphics is not
  particularly pretty.

* The text is not all the same colour; the final two words (but not the full
  stop) are red.  Furthermore, the final two words are **bold**;
  they have a different
  font face compared to the rest of the text.

  The R graphics system can only draw a character value with a single colour
  and a single font face.
  The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages make it possible to change colour within
  a character value, but they do not allow a mixture of plain text and
  mathematical expressions.

* The text is broken over multiple lines. Furthermore, the text is fully
  justified (not ragged-left or ragged-right justified) and one word
  has been split across lines and hyphenated. Although it is not
  obvious from the plot itself, the line breaks were also automatically
  generated to fit the text into a fixed width (3 inches).

  The R graphics system can draw a character value across multiple lines, but
  only if explicit newlines are embedded in the character value (i.e., the line
  breaks are manual). The \CRANpkg{gridtext} and 
  \CRANpkg{ggtext} packages can calculate simple
  automated line breaks, but they will not break a word across lines (or
  hyphenate) and they cannot fully justify the resulting text. The
  \CRANpkg{marquee} package can automate line breaks and fully justify
  text, but it cannot hyphenate nor can it produce mathematical equations.

The features outlined above are all examples of *typesetting*; determining an
arrangement of individual characters and symbols (glyphs) that could be as
simple as placing one character after another (from left to right), but could
also be as complex as arranging mathematical symbols, splitting text into
multiple columns, or writing text vertically from top to bottom.

From R 4.3.0, it has been
possible to draw text from a set of typeset glyphs using the
functions `grDevices::glyphInfo()` and `grid::grid.glyph()`
[@murrell-pedersen-urbanek-glyphs-2023]. However, that
facility presupposes that we are able to generate a set of typeset glyphs.

The \CRANpkg{marquee} package provides an example of a package
that can generate typeset glyphs.  It is capable of converting
markdown input into a set of glyphs and their positions, which are
then rendered in R.

This article describes the `xdvir` package, which is another example
of a package that can generate typeset glyphs.
In this case, the input is LaTeX, a TeX engine is used to
generate a set of glyphs and their positions, and then the
result is rendered in R.
The benefit of the `xdvir` package is that it provides access to the
typesetting capabilities of LaTeX, which includes hyphenation,
fully justified text, mixtures of plain text and mathematical equations---all
of the features demonstrated in Figure \@ref(fig:typesetting) and much more.

The next section describes the basic usage of the `xdvir` package.
This is followed by a section that breaks down the 
design of the `xdvir` package to show the steps that are
required to render LaTeX output in R.
Subsequent sections explore several of the complexities 
that can arise with rendering LaTeX text in R graphics and 
some of the solutions that 
the `xdvir` package provides.

# LaTeX text labels in R

The simplest way to draw LaTeX text with the `xdvir` package 
is to call the `grid.latex()` function.  The first argument to
this function is a character value, which is interpreted as
a fragment of LaTeX code.
For example, the following code draws a text label that contains
a fragment of the larger annotation from 
Figure \@ref(fig:typesetting).  We use just a fragment here in order
to keep the code readable.

Because LaTeX code tends to contain 
a large number of backslashes, the code below uses the `r"(...)"`
syntax for raw character constants, so that we do not have to
escape each backslash with a double backslash.
The resulting image is shown below the code.
Although it is not immediately obvious from that image, 
the text, or rather the glyphs, in the image are rendered by R.

```{r, fragment}
tex <- r"(We move the original mean to $\bar z_i$)"
```

```{r grid.latex, fig.width=3, fig.height=.5}
grid.rect()
grid.latex(tex)
```

It is possible to produce something similar to this result using 
the "plotmath" feature in R, as shown in the following code (and the image
below the code).  However, this demonstrates that
one advantage of using `xdvir`, even for a simple
piece of text like this, is the superior quality of the LaTeX 
fonts and typesetting for mathematical expressions.

```{r, plotmath}
plotmath <- expression("We move the original mean to "*bar(italic(z))[i])
```

```{r, fig.width=3, fig.height=.5}
grid.rect()
grid.text(plotmath)
```

Another immediate benefit of `xdvir` is that we can automatically fit
the text within a specified width.
For example, the following code draws the LaTeX fragment `tex`
again, but this time forces it to fit within a column that is half
the width of the image.

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.latex(tex, width=.5)
```

As the function name `grid.latex()` suggests, that function
produces low-level 
drawing in the `grid` package graphics system.
The text is just drawn relative to the current `grid` viewport,
wherever that may be on the page.
While this is extremely flexible, it is more likely that 
we want to combine and coordinate the text with a high-level plot
of some sort, like the annotation in Figure \@ref(fig:typesetting).
There are various ways that low-level `grid` drawing can be combined
with a high-level plot, but we will leave those demonstrations to
later sections.

Instead, for now, we will demonstrate a more common scenario:
drawing LaTeX text labels on a \CRANpkg{ggplot2} plot [@pkg-ggplot2].
For this purpose, the `xdvir` package provides the
`element_latex()` function.  This allows us to specify a LaTeX fragment
as a plot label and indicate the special nature of the label
via the `ggplot2::theme()` function.

For example, the following code uses the same LaTeX fragment 
from the example above as the title of a \CRANpkg{ggplot2} plot.
The resulting plot is shown in Figure \@ref(fig:elementlatex).
One detail about this result is that the text in this title is larger 
than the text drawn by the call to `grid.latex()` above.
A closer inspection reveals that the font is also different.
This reflects the fact that `grid.latex()` and `element_latex()`
respect the graphical parameter settings---font families and font sizes---that
are in effect when the LaTeX fragment is drawn.  In 
\@ref(fig:elementlatex) that means respecting the theme settings
of the \CRANpkg{ggplot2} plot.
This issue is discussed further in the next section.

The `ggIntro` object in the code below
contains a description of the main \CRANpkg{ggplot2} 
plot from Figure 
\@ref(fig:typesetting).
The code for generating 
`ggIntro` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

```{r, elementlatex, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=4.5, dpi=300, fig.cap="A `ggplot2` plot with a title that was specified using a LaTeX fragment."}
ggIntro +
    labs(title=tex) +
    theme(plot.title=element_latex())
```

The `xdvir` package also provides a `geom_latex()` function for
drawing text labels, similar to the standard `ggplot2::geom_text()` function.
The `label` aesthetic for `geom_latex()` is treated as a fragment of LaTeX
code.
For example, the following code draws a plot with a set of red points
and a set of red labels, one for each point.
The points are drawn using the standard `ggplot::geom_point()` function,
but the labels are drawn using `geom_latex()` from the `xdvir` package.
The result is shown in Figure \@ref(fig:geomlatex).

```{r echo=FALSE}
samples <- data.frame(x=rnorm(50), sample=rep(1:5, each=10))
means <- aggregate(samples$x, list(sample=samples$sample), mean)
means$label <- paste0("$\\bar x_", means$sample, "$")
xlabel <- r"(\begin{tikzpicture}\node[draw,circle,thick,inner sep=0.5mm]{\vphantom{M}$\mu$};\end{tikzpicture})"
```

```{r, echo=FALSE, message=FALSE}
ggGeom <- ggplot(samples) +
    geom_vline(xintercept=0, linetype="solid", colour=1, linewidth=.5) +
    geom_point(aes(x, sample), colour="grey", size=4, alpha=.5) +
    xlab(NULL) +
    scale_x_continuous(breaks=0, labels=xlabel) +
    scale_y_continuous(breaks=1:5, expand=expansion(.25)) +
    theme_minimal() +
    theme(axis.text.x=element_latex(size=16, packages="tikz", 
                                    margin=margin(-3, 0, 0, 0)),
          axis.ticks.x=element_blank(),
          axis.title.y=element_text(colour="grey"),
          axis.text.y=element_text(colour="grey"),
          panel.grid.major.x=element_blank(),
          panel.grid.minor.x=element_blank(),
          panel.grid.minor.y=element_blank())
```

The `ggGeom` object in the code below describes the 
main plot, consisting of grey dots, horizontal and vertical lines,
and y-axis labels.
The code for generating 
`ggGeom` is not shown in order to keep the code below readable,
but it is available in the supplementary materials for this article.

```{r, geomlatex, dev="png", dev.args=list(type="cairo"), fig.width=7, fig.height=3.5, dpi=300, fig.cap="A `ggplot2` plot with text labels drawn using `geom_latex()`."}
ggGeom +
    geom_point(aes(x, sample), data=means, colour=2, size=4) +
    geom_latex(aes(x, sample, label=label), data=means, 
               size=6, vjust=-.4, colour=2)    
```

The red labels for the red points in Figure \@ref(fig:geomlatex)
are small LaTeX fragments that each describe 
a simple LaTeX mathematical expression, as shown below.

```{r}
means$label
```

# Under the Hood

The previous section showed that simple usage of the `xdvir` package
only requires specifying a LaTeX fragment as the text to draw.
For example, the examples used the LaTeX fragment shown below.

```{r}
tex
```

The `grid.latex()` function has three tasks to perform in order to
draw that LaTeX fragment in R:

**Authoring:**

: The LaTeX fragment has to be turned into a complete
  LaTeX document.

: The `author()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code
  takes the LaTeX fragment `tex` and produces a complete LaTeX
  document that is ready to typeset.
  

```{r}
doc <- author(tex)
doc
```

**Typesetting:**

: The LaTeX document has to be typeset to produce a set of 
  glyphs and their positions.

: The `typeset()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the following code takes the LaTeX document `doc` and
  produces a `"DVI"` object that contains instructions on the fonts to
  use (lines that contain `x_fnt_def` and `fnt_num` in the output below), 
  the glyphs to use from those fonts (lines that contain
  `x_glyph` in the output below), and where to draw those glyphs
  (lines that contain `down` and `right` and `x_glyph`).

```{r}
dvi <- typeset(doc)
dvi
```  

**Rendering:**

: The result of the typesetting step has to be turned into drawing in R.

: The `grid.dvi()` function in the `xdvir` package 
  allows us to perform this step separately.
  For example, the code below renders the typesetting information in `dvi`
  in R.  The resulting image is shown below the code.

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.dvi(dvi)
```

One detail about the output above is that the rendered text from this
`grid.dvi()` call is 
smaller and in a different font from the example in the previous section
that was produced by a `grid.latex()` call.
This reflects the fact that `grid.latex()` respects the font family and
font size that are in effect when the text is rendered.
By contrast, the `grid.dvi()` call is drawing typeset information 
from a LaTeX document that just makes use of the default LaTeX font,
Computer Modern (or to be more precise, a modernised version called
Latin Modern).

# LaTeX packages

The code examples so far have dealt with relatively simple fragments of 
LaTeX code that consist of just text plus some simple mathematical expressions.
LaTeX code can be significantly more complex.  For example, 
the following fragment makes use of a LaTeX `minipage` environment to 
set the width of the text (this is actually more accurate than
setting the `width` argument as we saw in a previous section).

```{r}
minipage <- paste0(r"(\begin{minipage}{1.5in})",
                   tex,
                   r"(\end{minipage})")
```

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.latex(minipage)
```

Many additional effects can be obtained with LaTeX code by loading
LaTeX packages.  As a simple example, changes in text colour
requires loading the LaTeX package `xcolor`.
These packages can be loaded using the `packages` argument of the 
`grid.latex()` function (or the `element_latex()` or `geom_latex()` functions).
For example, the following code draws text with the last two
words in red.  

```{r}
colourTeX <- r"(We combine to get the \color{red}{Fitness Function})"
```

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.latex(colourTeX, packages="xcolor")
```

The `packages` argument plays two important roles.
It affects the authoring step to make sure that the package is loaded
in the LaTeX document.

```{r}
colourDoc <- author(colourTeX, packages="xcolor")
colourDoc
```

Without this, the typesetting step would fail because the LaTeX code
`\color{red}` would not be recognised.
The changes in colour can be seen in the `"DVI"` output below
(lines that contain `xxx` and `color push` or `color pop`).

```{r}
colourDVI <- typeset(colourDoc)
colourDVI
```

The `packages` argument also affects the rendering step to make sure
that R responds to the `color push` and `color pop` operations.

```{r fig.width=3, fig.height=.5}
grid.rect()
grid.dvi(colourDVI, packages="xcolor")
```

fontspec and xcolor

Show the document created by 

# Justifying text

preview

# Integrating text

marks

# LaTeX graphics

tikz

# Fancy annotated equation example [@schneider2023]

+ NOTE that this nicely uses {ggtext} for simpler annotations, but
  has to go to LaTeX for fancy stuff
  => exactly the justification for {xdvir}

+ NOTE this is also an example of writing new LaTeXpackage()

```{r echo=FALSE}
library(ggtext)
library(signs)
```

```{r echo=FALSE}
## Set up "data"
mu <- 100
sigma <- 15
plot_height <- dnorm(mu, mu, sigma)
lb <- -4 * sigma + mu
ub <- 4 * sigma + mu
```

```{r echo=FALSE}
## Set up main plot
## NOTE need some data for grid_panel() to be called at all
gg <- ggplot(data.frame(x=160, y=dnorm(mu, mean=mu, sd=sigma))) +
    stat_function(fun=function(x) dnorm(x, mean=mu, sd=sigma),
                  geom="area",
                  n=1000,
                  fill="dodgerblue",
                  alpha=.5) +
    theme_classic(base_family="Roboto Condensed",
                  base_size=18) +
    theme(axis.text.x=element_markdown(),
          axis.title.x=element_markdown(),
          axis.line=element_blank())  +
    scale_x_continuous("Observed Score *X*<br>*z*",
                       breaks=seq(lb, ub, sigma),
                       limits=c(lb, ub),
                       labels=function(x)
                           paste0(signs(x),
                                  "<br>",
                                  ifelse(x == mu,
                                         "<em>&mu;</em>",
                                         paste0(signs((x - mu) / sigma,
                                                      add_plusses=T,
                                                      label_at_zero="none"),
                                                "<em>&sigma;</em>")))) +
    scale_y_continuous(NULL,
                       limits=c(0, plot_height),
                       expand=expansion(),
                       breaks=NULL) 
```

```{r echo=FALSE}
## Add {xdvir} annotation
library(xdvir)
library(gggrid)

annotateEquations <-
    LaTeXpackage(name="annotate",
                 preamble="\\usepackage{annotate-equations/annotate-equations}")
registerPackage(annotateEquations)
roboto <-
    LaTeXpackage(name="roboto",
                 preamble="\\usepackage[sfdefault,condensed]{roboto}")
registerPackage(roboto)
tikzNoBBox <-
    tikzPackage(name="tikzNoBBox", bbox=FALSE)
registerPackage(tikzNoBBox)

pkgs <- c("xcolor", "tikzNoBBox", "annotate", "roboto")

tex <- author(readLines("TeX/schneider.tex"), packages=pkgs)
dvi <- typeset(tex, texFile="TeX/schneider-doc.tex")

annotation <- function(data, coords) {
    dviGrob(dvi, packages=pkgs,
            x=unit(coords$x, "npc") + 0.5*stringWidth("160"),
            y=coords$y, hjust=1, vjust=1)
}

gg +
    grid_panel(annotation, aes(x=x, y=y))
```

# Use dvir-lualatex-float example 

Text typeset within irregular shape.
Example of more work happening in LaTeX code.
Example of grid.dvi() just dumped on top of other drawing
=> motivation for better alignment examples.

```{r echo=FALSE}
tex <- author(readLines("TeX/longley.tex"), packages="fontspec")
dvi <- typeset(tex, texFile="TeX/longley-doc.tex")
par(mar=c(4, 4, 1, 1))
barplot(GNP ~ Year, data = longley)
grid.dvi(dvi,
         x=unit(2.5, "cm"),
         y=unit(1, "npc") - unit(1, "cm"),
         hjust="left", vjust="top")
```

# RTL or Vertical layout example?

# Alignment

Do tikz example that draws arrow to location on plot?
(like dvir-tikz test)

Do example that draws grid arrow to location in tikz picture?
(needs implementing)

# Anzjs example 

# gggrid

Need a \CRANpkg{gggrid} package 
[@pkg-gggrid] example.

# Acknowledgements

Must acknowledge tikzDevice package !!!

Owe big debt to the \CRANpkg{tinytex} package,
which simplifies the calling of TeX engines, installation
of TeX packages (and TeX itself),
and running TeX multiple times when necessary (e.g., for TikZ
position tracking).

# Summary

